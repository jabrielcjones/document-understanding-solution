"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StackParameters = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const stack_status_1 = require("./cloudformation/stack-status");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    constructor(cfn, stackName, stack) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
    }
    static async lookup(cfn, stackName) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0]);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({ StackName: this.stackName, TemplateStage: 'Original' }).promise();
            this._template = (response.TemplateBody && serialize_1.deserializeStructure(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list of the stack does not exist
     */
    get tags() {
        var _a;
        return ((_a = this.stack) === null || _a === void 0 ? void 0 : _a.Tags) || [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        var _a;
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of (_a = this.stack.Parameters) !== null && _a !== void 0 ? _a : []) {
            ret[param.ParameterKey] = param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        var _a;
        return (_a = this.stack) === null || _a === void 0 ? void 0 : _a.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn       a CloudFormation client
 * @param stackName   the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName) {
    logging_1.debug('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName);
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            logging_1.debug('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        'The submitted information didn\'t contain changes.',
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return description.Status === 'FAILED'
        && noChangeErrorPrefixes.some(p => { var _a; return ((_a = description.StatusReason) !== null && _a !== void 0 ? _a : '').startsWith(p); });
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    logging_1.debug('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            logging_1.debug('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            logging_1.debug('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
class TemplateParameters {
    constructor(params) {
        this.params = params;
    }
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    toStackParameters(updates) {
        return new StackParameters(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    diff(updates, previousValues) {
        return new StackParameters(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
class StackParameters {
    constructor(params, updates, previousValues = {}) {
        this.params = params;
        /**
         * The CloudFormation parameters to pass to the CreateStack or UpdateStack API
         */
        this.apiParameters = [];
        this._changes = false;
        const missingRequired = new Array();
        for (const [key, param] of Object.entries(this.params)) {
            // If any of the parameters are SSM parameters, they will always lead to a change
            if (param.Type.startsWith('AWS::SSM::Parameter::')) {
                this._changes = true;
            }
            if (key in updates && updates[key] !== undefined) {
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                // If the updated value is different than the current value, this will lead to a change
                if (!(key in previousValues) || updates[key] !== previousValues[key]) {
                    this._changes = true;
                }
            }
            else if (key in previousValues) {
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
            }
            else if (param.Default === undefined) {
                missingRequired.push(key);
            }
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.params[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    get changed() {
        return this._changes;
    }
}
exports.StackParameters = StackParameters;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSwyQ0FBc0M7QUFDdEMsK0NBQXVEO0FBQ3ZELGdFQUE0RDtBQWE1RDs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBK0I5QixZQUF1QyxHQUFtQixFQUFrQixTQUFpQixFQUFtQixLQUE0QjtRQUFyRyxRQUFHLEdBQUgsR0FBRyxDQUFnQjtRQUFrQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQW1CLFVBQUssR0FBTCxLQUFLLENBQXVCO0lBQzVJLENBQUM7SUEvQk0sTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBbUIsRUFBRSxTQUFpQjtRQUMvRCxJQUFJO1lBQ0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDOUUsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkY7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBaUIsSUFBSSxDQUFDLENBQUMsT0FBTyxLQUFLLGlCQUFpQixTQUFTLGlCQUFpQixFQUFFO2dCQUM3RixPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FBQzthQUMzRDtZQUNELE1BQU0sQ0FBQyxDQUFDO1NBQ1Q7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBbUIsRUFBRSxTQUFpQjtRQUMvRCxPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRDs7T0FFRztJQUNJLE1BQU0sQ0FBQyxxQkFBcUIsQ0FBQyxHQUFtQixFQUFFLFNBQWlCLEVBQUUsS0FBMkI7UUFDckcsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQU9EOzs7OztPQUtHO0lBQ0ksS0FBSyxDQUFDLFFBQVE7UUFDbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDaEIsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxTQUFTLEVBQUU7WUFDaEMsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFLGFBQWEsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ2hILElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxRQUFRLENBQUMsWUFBWSxJQUFJLGdDQUFvQixDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztTQUMvRjtRQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUN4QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLE1BQU07UUFDZixPQUFPLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxPQUFPO1FBQ2hCLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNwQixPQUFPLElBQUksQ0FBQyxLQUFNLENBQUMsT0FBUSxDQUFDO0lBQzlCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxPQUFPO1FBQ2hCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQUUsT0FBTyxFQUFFLENBQUM7U0FBRTtRQUNoQyxNQUFNLE1BQU0sR0FBK0IsRUFBRSxDQUFDO1FBQzlDLENBQUMsSUFBSSxDQUFDLEtBQU0sQ0FBQyxPQUFPLElBQUksRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzNDLE1BQU0sQ0FBQyxNQUFNLENBQUMsU0FBVSxDQUFDLEdBQUcsTUFBTSxDQUFDLFdBQVksQ0FBQztRQUNsRCxDQUFDLENBQUMsQ0FBQztRQUNILE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxXQUFXO1FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO1lBQ2hCLE9BQU8sSUFBSSwwQkFBVyxDQUFDLFdBQVcsRUFBRSwrQkFBK0IsQ0FBQyxDQUFDO1NBQ3RFO1FBQ0QsT0FBTywwQkFBVyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFNLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsSUFBSTs7UUFDYixPQUFPLE9BQUEsSUFBSSxDQUFDLEtBQUssMENBQUUsSUFBSSxLQUFJLEVBQUUsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsY0FBYztRQUN2QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxVQUFVOztRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUFFLE9BQU8sRUFBRSxDQUFDO1NBQUU7UUFDaEMsTUFBTSxHQUFHLEdBQTJCLEVBQUUsQ0FBQztRQUN2QyxLQUFLLE1BQU0sS0FBSyxVQUFJLElBQUksQ0FBQyxLQUFNLENBQUMsVUFBVSxtQ0FBSSxFQUFFLEVBQUU7WUFDaEQsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFhLENBQUMsR0FBRyxLQUFLLENBQUMsY0FBZSxDQUFDO1NBQ2xEO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLHFCQUFxQjs7UUFDOUIsYUFBTyxJQUFJLENBQUMsS0FBSywwQ0FBRSwyQkFBMkIsQ0FBQztJQUNqRCxDQUFDO0lBRU8sWUFBWTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNoQixNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQztTQUN2RDtJQUNILENBQUM7Q0FDRjtBQTNJRCxrREEySUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILEtBQUssVUFBVSxpQkFBaUIsQ0FBQyxHQUFtQixFQUFFLFNBQWlCLEVBQUUsYUFBcUI7SUFDNUYsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsaUJBQWlCLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQy9HLE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7QUFFRDs7Ozs7OztHQU9HO0FBQ0gsS0FBSyxVQUFVLE9BQU8sQ0FBSSxhQUFrRCxFQUFFLFVBQWtCLElBQUk7SUFDbEcsT0FBTyxJQUFJLEVBQUU7UUFDWCxNQUFNLE1BQU0sR0FBRyxNQUFNLGFBQWEsRUFBRSxDQUFDO1FBQ3JDLElBQUksTUFBTSxLQUFLLElBQUksRUFBRTtZQUNuQixPQUFPLFNBQVMsQ0FBQztTQUNsQjthQUFNLElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUMvQixPQUFPLE1BQU0sQ0FBQztTQUNmO1FBQ0QsTUFBTSxJQUFJLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztLQUNsRDtBQUNILENBQUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNILG1DQUFtQztBQUM1QixLQUFLLFVBQVUsZ0JBQWdCLENBQUMsR0FBbUIsRUFBRSxTQUFpQixFQUFFLGFBQXFCO0lBQ2xHLGVBQUssQ0FBQyw0REFBNEQsRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDOUYsTUFBTSxHQUFHLEdBQUcsTUFBTSxPQUFPLENBQUMsS0FBSyxJQUFJLEVBQUU7UUFDbkMsTUFBTSxXQUFXLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQzNFLGtHQUFrRztRQUNsRyxrRkFBa0Y7UUFDbEYsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLGdCQUFnQixJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssb0JBQW9CLEVBQUU7WUFDMUYsZUFBSyxDQUFDLDRDQUE0QyxFQUFFLGFBQWEsRUFBRSxTQUFTLENBQUMsQ0FBQztZQUM5RSxPQUFPLFNBQVMsQ0FBQztTQUNsQjtRQUVELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxpQkFBaUIsSUFBSSxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNsRixPQUFPLFdBQVcsQ0FBQztTQUNwQjtRQUVELG1DQUFtQztRQUNuQyxNQUFNLElBQUksS0FBSyxDQUFDLDhCQUE4QixhQUFhLE9BQU8sU0FBUyxLQUFLLFdBQVcsQ0FBQyxNQUFNLElBQUksV0FBVyxLQUFLLFdBQVcsQ0FBQyxZQUFZLElBQUksb0JBQW9CLEVBQUUsQ0FBQyxDQUFDO0lBQzVLLENBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQztLQUNyRTtJQUVELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQXhCRCw0Q0F3QkM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixxQkFBcUIsQ0FBQyxXQUFtRDtJQUN2RixNQUFNLHFCQUFxQixHQUFHO1FBQzVCLHVDQUF1QztRQUN2QyxvREFBb0Q7UUFDcEQsMERBQTBEO1FBQzFELGlDQUFpQztLQUNsQyxDQUFDO0lBRUYsT0FBTyxXQUFXLENBQUMsTUFBTSxLQUFLLFFBQVE7V0FDakMscUJBQXFCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQUMsT0FBQSxPQUFDLFdBQVcsQ0FBQyxZQUFZLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQSxFQUFBLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBVkQsc0RBVUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNJLEtBQUssVUFBVSxrQkFBa0IsQ0FDdEMsR0FBbUIsRUFDbkIsU0FBaUI7SUFFakIsTUFBTSxLQUFLLEdBQUcsTUFBTSxjQUFjLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxLQUFLLEVBQUU7UUFBRSxPQUFPLFNBQVMsQ0FBQztLQUFFO0lBRWpDLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7SUFDakMsSUFBSSxNQUFNLENBQUMsU0FBUyxFQUFFO1FBQ3BCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLFNBQVMsMkVBQTJFLE1BQU0sRUFBRSxDQUFDLENBQUM7S0FDbEk7U0FBTSxJQUFJLE1BQU0sQ0FBQyxTQUFTLEVBQUU7UUFDM0IsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFkRCxnREFjQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLEdBQW1CLEVBQ25CLFNBQWlCO0lBRWpCLE1BQU0sS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQUUsT0FBTyxTQUFTLENBQUM7S0FBRTtJQUVqQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO0lBRWpDLElBQUksTUFBTSxDQUFDLGlCQUFpQixFQUFFO1FBQzVCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLFNBQVMsOEVBQThFLE1BQU0sRUFBRSxDQUFDLENBQUM7S0FDckk7U0FBTSxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRTtRQUNsQyxNQUFNLElBQUksS0FBSyxDQUFDLG1CQUFtQixTQUFTLHNCQUFzQixNQUFNLEVBQUUsQ0FBQyxDQUFDO0tBQzdFO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBaEJELGdEQWdCQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGNBQWMsQ0FBQyxHQUFtQixFQUFFLFNBQWlCO0lBQ3pFLGVBQUssQ0FBQyx3REFBd0QsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUMzRSxPQUFPLE9BQU8sQ0FBQyxLQUFLLElBQUksRUFBRTtRQUN4QixNQUFNLEtBQUssR0FBRyxNQUFNLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDakIsZUFBSyxDQUFDLHlCQUF5QixFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzVDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO1FBQ2pDLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTtZQUN2QixlQUFLLENBQUMsc0VBQXNFLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2pHLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFoQkQsd0NBZ0JDO0FBRUQsTUFBYSxrQkFBa0I7SUFLN0IsWUFBNkIsTUFBeUM7UUFBekMsV0FBTSxHQUFOLE1BQU0sQ0FBbUM7SUFDdEUsQ0FBQztJQUxNLE1BQU0sQ0FBQyxZQUFZLENBQUMsUUFBa0I7UUFDM0MsT0FBTyxJQUFJLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxVQUFVLElBQUksRUFBRSxDQUFDLENBQUM7SUFDM0QsQ0FBQztJQUtEOzs7OztPQUtHO0lBQ0ksaUJBQWlCLENBQUMsT0FBMkM7UUFDbEUsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksSUFBSSxDQUFDLE9BQTJDLEVBQUUsY0FBc0M7UUFDN0YsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUE3QkQsZ0RBNkJDO0FBRUQsTUFBYSxlQUFlO0lBUTFCLFlBQ21CLE1BQXlDLEVBQzFELE9BQTJDLEVBQzNDLGlCQUF5QyxFQUFFO1FBRjFCLFdBQU0sR0FBTixNQUFNLENBQW1DO1FBUjVEOztXQUVHO1FBQ2Esa0JBQWEsR0FBK0IsRUFBRSxDQUFDO1FBRXZELGFBQVEsR0FBRyxLQUFLLENBQUM7UUFPdkIsTUFBTSxlQUFlLEdBQUcsSUFBSSxLQUFLLEVBQVUsQ0FBQztRQUU1QyxLQUFLLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDdEQsaUZBQWlGO1lBQ2pGLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsRUFBRTtnQkFDbEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7YUFDdEI7WUFFRCxJQUFJLEdBQUcsSUFBSSxPQUFPLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLFNBQVMsRUFBRTtnQkFDaEQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsRUFBRSxZQUFZLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO2dCQUU3RSx1RkFBdUY7Z0JBQ3ZGLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxjQUFjLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFO29CQUNwRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztpQkFDdEI7YUFDRjtpQkFBTSxJQUFJLEdBQUcsSUFBSSxjQUFjLEVBQUU7Z0JBQ2hDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO2FBQ3hFO2lCQUFNLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxTQUFTLEVBQUU7Z0JBQ3RDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7YUFDM0I7U0FDRjtRQUVELElBQUksZUFBZSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDOUIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsZUFBZSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDL0c7UUFFRCx1RUFBdUU7UUFDdkUsMEVBQTBFO1FBQzFFLE1BQU07UUFDTixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTLENBQUM7UUFDakYsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDeEQsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN4RixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsY0FBYyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7U0FDdkU7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxJQUFXLE9BQU87UUFDaEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3ZCLENBQUM7Q0FDRjtBQXZERCwwQ0F1REMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9sb2dnaW5nJztcbmltcG9ydCB7IGRlc2VyaWFsaXplU3RydWN0dXJlIH0gZnJvbSAnLi4vLi4vc2VyaWFsaXplJztcbmltcG9ydCB7IFN0YWNrU3RhdHVzIH0gZnJvbSAnLi9jbG91ZGZvcm1hdGlvbi9zdGFjay1zdGF0dXMnO1xuXG5leHBvcnQgdHlwZSBUZW1wbGF0ZSA9IHtcbiAgUGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPjtcbiAgW2tleTogc3RyaW5nXTogYW55O1xufTtcblxuaW50ZXJmYWNlIFRlbXBsYXRlUGFyYW1ldGVyIHtcbiAgVHlwZTogc3RyaW5nO1xuICBEZWZhdWx0PzogYW55O1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiAoZXhpc3RpbmcpIFN0YWNrIGluIENsb3VkRm9ybWF0aW9uXG4gKlxuICogQnVuZGxlIGFuZCBjYWNoZSBzb21lIGluZm9ybWF0aW9uIHRoYXQgd2UgbmVlZCBkdXJpbmcgZGVwbG95bWVudCAoc28gd2UgZG9uJ3QgaGF2ZSB0byBtYWtlXG4gKiByZXBlYXRlZCBjYWxscyB0byBDbG91ZEZvcm1hdGlvbikuXG4gKi9cbmV4cG9ydCBjbGFzcyBDbG91ZEZvcm1hdGlvblN0YWNrIHtcbiAgcHVibGljIHN0YXRpYyBhc3luYyBsb29rdXAoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uU3RhY2s+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVTdGFja3MoeyBTdGFja05hbWU6IHN0YWNrTmFtZSB9KS5wcm9taXNlKCk7XG4gICAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHJlc3BvbnNlLlN0YWNrcyAmJiByZXNwb25zZS5TdGFja3NbMF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdWYWxpZGF0aW9uRXJyb3InICYmIGUubWVzc2FnZSA9PT0gYFN0YWNrIHdpdGggaWQgJHtzdGFja05hbWV9IGRvZXMgbm90IGV4aXN0YCkge1xuICAgICAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb3B5IG9mIHRoZSBnaXZlbiBzdGFjayB0aGF0IGRvZXMgbm90IGV4aXN0XG4gICAqXG4gICAqIEl0J3MgYSBsaXR0bGUgc2lsbHkgdGhhdCBpdCBuZWVkcyBhcmd1bWVudHMgdG8gZG8gdGhhdCwgYnV0IHRoZXJlIHdlIGdvLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBkb2VzTm90RXhpc3QoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gc3RhdGljIGluZm9ybWF0aW9uIChmb3IgdGVzdGluZylcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVN0YXRpY0luZm9ybWF0aW9uKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCBzdGFjazogQ2xvdWRGb3JtYXRpb24uU3RhY2spIHtcbiAgICByZXR1cm4gbmV3IENsb3VkRm9ybWF0aW9uU3RhY2soY2ZuLCBzdGFja05hbWUsIHN0YWNrKTtcbiAgfVxuXG4gIHByaXZhdGUgX3RlbXBsYXRlOiBhbnk7XG5cbiAgcHJvdGVjdGVkIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgY2ZuOiBDbG91ZEZvcm1hdGlvbiwgcHVibGljIHJlYWRvbmx5IHN0YWNrTmFtZTogc3RyaW5nLCBwcml2YXRlIHJlYWRvbmx5IHN0YWNrPzogQ2xvdWRGb3JtYXRpb24uU3RhY2spIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3RhY2sncyBkZXBsb3llZCB0ZW1wbGF0ZVxuICAgKlxuICAgKiBDYWNoZWQsIHNvIHdpbGwgb25seSBiZSByZXRyaWV2ZWQgb25jZS4gV2lsbCByZXR1cm4gYW4gZW1wdHlcbiAgICogc3RydWN0dXJlIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB0ZW1wbGF0ZSgpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2ZuLmdldFRlbXBsYXRlKHsgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSwgVGVtcGxhdGVTdGFnZTogJ09yaWdpbmFsJyB9KS5wcm9taXNlKCk7XG4gICAgICB0aGlzLl90ZW1wbGF0ZSA9IChyZXNwb25zZS5UZW1wbGF0ZUJvZHkgJiYgZGVzZXJpYWxpemVTdHJ1Y3R1cmUocmVzcG9uc2UuVGVtcGxhdGVCb2R5KSkgfHwge307XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBzdGFjayBleGlzdHNcbiAgICovXG4gIHB1YmxpYyBnZXQgZXhpc3RzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3MgSURcbiAgICpcbiAgICogVGhyb3dzIGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBzdGFja0lkKCkge1xuICAgIHRoaXMuYXNzZXJ0RXhpc3RzKCk7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2shLlN0YWNrSWQhO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIGN1cnJlbnQgb3V0cHV0c1xuICAgKlxuICAgKiBFbXB0eSBvYmplY3QgaWYgdGhlIHN0YWNrIGRvZXNuJ3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgb3V0cHV0cygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7IHJldHVybiB7fTsgfVxuICAgIGNvbnN0IHJlc3VsdDogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAodGhpcy5zdGFjayEuT3V0cHV0cyB8fCBbXSkuZm9yRWFjaChvdXRwdXQgPT4ge1xuICAgICAgcmVzdWx0W291dHB1dC5PdXRwdXRLZXkhXSA9IG91dHB1dC5PdXRwdXRWYWx1ZSE7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBzdGF0dXNcbiAgICpcbiAgICogU3BlY2lhbCBzdGF0dXMgTk9UX0ZPVU5EIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tTdGF0dXMoKTogU3RhY2tTdGF0dXMge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHtcbiAgICAgIHJldHVybiBuZXcgU3RhY2tTdGF0dXMoJ05PVF9GT1VORCcsICdTdGFjayBub3QgZm91bmQgZHVyaW5nIGxvb2t1cCcpO1xuICAgIH1cbiAgICByZXR1cm4gU3RhY2tTdGF0dXMuZnJvbVN0YWNrRGVzY3JpcHRpb24odGhpcy5zdGFjayEpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIGN1cnJlbnQgdGFnc1xuICAgKlxuICAgKiBFbXB0eSBsaXN0IG9mIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdFxuICAgKi9cbiAgcHVibGljIGdldCB0YWdzKCk6IENsb3VkRm9ybWF0aW9uLlRhZ3Mge1xuICAgIHJldHVybiB0aGlzLnN0YWNrPy5UYWdzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmFtZXMgb2YgYWxsIGN1cnJlbnQgcGFyYW1ldGVycyB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogRW1wdHkgbGlzdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHBhcmFtZXRlck5hbWVzKCk6IHN0cmluZ1tdIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgYWxsIGN1cnJlbnQgcGFyYW1ldGVycyB0byB0aGUgc3RhY2tcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGFyYW1ldGVycygpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7IHJldHVybiB7fTsgfVxuICAgIGNvbnN0IHJldDogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5zdGFjayEuUGFyYW1ldGVycyA/PyBbXSkge1xuICAgICAgcmV0W3BhcmFtLlBhcmFtZXRlcktleSFdID0gcGFyYW0uUGFyYW1ldGVyVmFsdWUhO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdGVybWluYXRpb24gcHJvdGVjdGlvbiBvZiB0aGUgc3RhY2tcbiAgICovXG4gIHB1YmxpYyBnZXQgdGVybWluYXRpb25Qcm90ZWN0aW9uKCk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YWNrPy5FbmFibGVUZXJtaW5hdGlvblByb3RlY3Rpb247XG4gIH1cblxuICBwcml2YXRlIGFzc2VydEV4aXN0cygpIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN0YWNrIG5hbWVkICcke3RoaXMuc3RhY2tOYW1lfSdgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXNjcmliZSBhIGNoYW5nZXNldCBpbiBDbG91ZEZvcm1hdGlvbiwgcmVnYXJkbGVzcyBvZiBpdHMgY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoZSBDaGFuZ2VTZXQgYmVsb25ncyB0b1xuICogQHBhcmFtIGNoYW5nZVNldE5hbWUgdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICpcbiAqIEByZXR1cm5zICAgICAgIENsb3VkRm9ybWF0aW9uIGluZm9ybWF0aW9uIGFib3V0IHRoZSBDaGFuZ2VTZXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVDaGFuZ2VTZXQoY2ZuOiBDbG91ZEZvcm1hdGlvbiwgc3RhY2tOYW1lOiBzdHJpbmcsIGNoYW5nZVNldE5hbWU6IHN0cmluZyk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb24uRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQ+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVDaGFuZ2VTZXQoeyBTdGFja05hbWU6IHN0YWNrTmFtZSwgQ2hhbmdlU2V0TmFtZTogY2hhbmdlU2V0TmFtZSB9KS5wcm9taXNlKCk7XG4gIHJldHVybiByZXNwb25zZTtcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBmdW5jdGlvbiB0byByZXR1cm4gbm9uLSt1bmRlZmluZWQrIGJlZm9yZSByZXR1cm5pbmcuXG4gKlxuICogQHBhcmFtIHZhbHVlUHJvdmlkZXIgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0dXJuIGEgdmFsdWUgdGhhdCBpcyBub3QgK3VuZGVmaW5lZCsgb25jZSB0aGUgd2FpdCBzaG91bGQgYmUgb3ZlclxuICogQHBhcmFtIHRpbWVvdXQgICAgIHRoZSB0aW1lIHRvIHdhaXQgYmV0d2VlbiB0d28gY2FsbHMgdG8gK3ZhbHVlUHJvdmlkZXIrXG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIHZhbHVlIHRoYXQgd2FzIHJldHVybmVkIGJ5ICt2YWx1ZVByb3ZpZGVyK1xuICovXG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yPFQ+KHZhbHVlUHJvdmlkZXI6ICgpID0+IFByb21pc2U8VCB8IG51bGwgfCB1bmRlZmluZWQ+LCB0aW1lb3V0OiBudW1iZXIgPSA1MDAwKTogUHJvbWlzZTxUIHwgdW5kZWZpbmVkPiB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWVQcm92aWRlcigpO1xuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYXdhaXQgbmV3IFByb21pc2UoY2IgPT4gc2V0VGltZW91dChjYiwgdGltZW91dCkpO1xuICB9XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgQ2hhbmdlU2V0IHRvIGJlIGF2YWlsYWJsZSBmb3IgdHJpZ2dlcmluZyBhIFN0YWNrVXBkYXRlLlxuICpcbiAqIFdpbGwgcmV0dXJuIGEgY2hhbmdlc2V0IHRoYXQgaXMgZWl0aGVyIHJlYWR5IHRvIGJlIGV4ZWN1dGVkIG9yIGhhcyBubyBjaGFuZ2VzLlxuICogV2lsbCB0aHJvdyBpbiBvdGhlciBjYXNlcy5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgdGhlIG5hbWUgb2YgdGhlIFN0YWNrIHRoYXQgdGhlIENoYW5nZVNldCBiZWxvbmdzIHRvXG4gKiBAcGFyYW0gY2hhbmdlU2V0TmFtZSB0aGUgbmFtZSBvZiB0aGUgQ2hhbmdlU2V0XG4gKlxuICogQHJldHVybnMgICAgICAgdGhlIENsb3VkRm9ybWF0aW9uIGRlc2NyaXB0aW9uIG9mIHRoZSBDaGFuZ2VTZXRcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yQ2hhbmdlU2V0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCBjaGFuZ2VTZXROYW1lOiBzdHJpbmcpOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCBkZXNjcmliZUNoYW5nZVNldChjZm4sIHN0YWNrTmFtZSwgY2hhbmdlU2V0TmFtZSk7XG4gICAgLy8gVGhlIGZvbGxvd2luZyBkb2Vzbid0IHVzZSBhIHN3aXRjaCBiZWNhdXNlIHRzYyB3aWxsIG5vdCBhbGxvdyBmYWxsLXRocm91Z2gsIFVOTEVTUyBpdCBpcyBhbGxvd3NcbiAgICAvLyBFVkVSWVdIRVJFIHRoYXQgdXNlcyB0aGlzIGxpYnJhcnkgZGlyZWN0bHkgb3IgaW5kaXJlY3RseSwgd2hpY2ggaXMgdW5kZXNpcmFibGUuXG4gICAgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9QRU5ESU5HJyB8fCBkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdDUkVBVEVfSU5fUFJPR1JFU1MnKSB7XG4gICAgICBkZWJ1ZygnQ2hhbmdlc2V0ICVzIG9uIHN0YWNrICVzIGlzIHN0aWxsIGNyZWF0aW5nJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9DT01QTEVURScgfHwgY2hhbmdlU2V0SGFzTm9DaGFuZ2VzKGRlc2NyaXB0aW9uKSkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIENoYW5nZVNldCAke2NoYW5nZVNldE5hbWV9IG9uICR7c3RhY2tOYW1lfTogJHtkZXNjcmlwdGlvbi5TdGF0dXMgfHwgJ05PX1NUQVRVUyd9LCAke2Rlc2NyaXB0aW9uLlN0YXR1c1JlYXNvbiB8fCAnbm8gcmVhc29uIHByb3ZpZGVkJ31gKTtcbiAgfSk7XG5cbiAgaWYgKCFyZXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5nZSBzZXQgdG9vayB0b28gbG9uZyB0byBiZSBjcmVhdGVkOyBhYm9ydGluZycpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2hhbmdlIHNldCBoYXMgbm8gY2hhbmdlc1xuICpcbiAqIFRoaXMgbXVzdCBiZSBkZXRlcm1pbmVkIGZyb20gdGhlIHN0YXR1cywgbm90IHRoZSAnQ2hhbmdlcycgYXJyYXkgb24gdGhlXG4gKiBvYmplY3Q7IHRoZSBsYXR0ZXIgY2FuIGJlIGVtcHR5IGJlY2F1c2Ugbm8gcmVzb3VyY2VzIHdlcmUgY2hhbmdlZCwgYnV0IGlmXG4gKiB0aGVyZSBhcmUgY2hhbmdlcyB0byBPdXRwdXRzLCB0aGUgY2hhbmdlIHNldCBjYW4gc3RpbGwgYmUgZXhlY3V0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoZGVzY3JpcHRpb246IENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0KSB7XG4gIGNvbnN0IG5vQ2hhbmdlRXJyb3JQcmVmaXhlcyA9IFtcbiAgICAvLyBFcnJvciBtZXNzYWdlIGZvciBhIHJlZ3VsYXIgdGVtcGxhdGVcbiAgICAnVGhlIHN1Ym1pdHRlZCBpbmZvcm1hdGlvbiBkaWRuXFwndCBjb250YWluIGNoYW5nZXMuJyxcbiAgICAvLyBFcnJvciBtZXNzYWdlIHdoZW4gYSBUcmFuc2Zvcm0gaXMgaW52b2x2ZWQgKHNlZSAjMTA2NTApXG4gICAgJ05vIHVwZGF0ZXMgYXJlIHRvIGJlIHBlcmZvcm1lZC4nLFxuICBdO1xuXG4gIHJldHVybiBkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdGQUlMRUQnXG4gICAgJiYgbm9DaGFuZ2VFcnJvclByZWZpeGVzLnNvbWUocCA9PiAoZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uID8/ICcnKS5zdGFydHNXaXRoKHApKTtcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDbG91ZEZvcm1hdGlvbiBzdGFjayB0byBzdGFiaWxpemUgaW4gYSBjb21wbGV0ZS9hdmFpbGFibGUgc3RhdGVcbiAqIGFmdGVyIGEgZGVsZXRlIG9wZXJhdGlvbiBpcyBpc3N1ZWQuXG4gKlxuICogRmFpbHMgaWYgdGhlIHN0YWNrIGlzIGluIGEgRkFJTEVEIHN0YXRlLiBXaWxsIG5vdCBmYWlsIGlmIHRoZSBzdGFjayB3YXNcbiAqIGFscmVhZHkgZGVsZXRlZC5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvciBhZnRlciBhIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIGRlbGV0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZWxldGUoXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuICBpZiAoc3RhdHVzLmlzRmFpbHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBpcyBpbiBhIGZhaWxlZCBzdGF0ZS4gWW91IG1heSBuZWVkIHRvIGRlbGV0ZSBpdCBmcm9tIHRoZSBBV1MgY29uc29sZSA6ICR7c3RhdHVzfWApO1xuICB9IGVsc2UgaWYgKHN0YXR1cy5pc0RlbGV0ZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGFjaztcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDbG91ZEZvcm1hdGlvbiBzdGFjayB0byBzdGFiaWxpemUgaW4gYSBjb21wbGV0ZS9hdmFpbGFibGUgc3RhdGVcbiAqIGFmdGVyIGFuIHVwZGF0ZS9jcmVhdGUgb3BlcmF0aW9uIGlzIGlzc3VlZC5cbiAqXG4gKiBGYWlscyBpZiB0aGUgc3RhY2sgaXMgaW4gYSBGQUlMRUQgc3RhdGUsIFJPTExCQUNLIHN0YXRlLCBvciBERUxFVEVEIHN0YXRlLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICAgdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIHdhaXQgZm9yIGFmdGVyIGFuIHVwZGF0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIHVwZGF0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZXBsb3koXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuXG4gIGlmIChzdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gZmFpbGVkIGNyZWF0aW9uLCBpdCBtYXkgbmVlZCB0byBiZSBtYW51YWxseSBkZWxldGVkIGZyb20gdGhlIEFXUyBjb25zb2xlOiAke3N0YXR1c31gKTtcbiAgfSBlbHNlIGlmICghc3RhdHVzLmlzRGVwbG95U3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgdG8gZGVwbG95OiAke3N0YXR1c31gKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn1cblxuLyoqXG4gKiBXYWl0IGZvciBhIHN0YWNrIHRvIGJlY29tZSBzdGFibGUgKG5vIGxvbmdlciBfSU5fUFJPR1JFU1MpLCByZXR1cm5pbmcgaXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YWJpbGl6ZVN0YWNrKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBzdGFjayAlcyB0byBmaW5pc2ggY3JlYXRpbmcgb3IgdXBkYXRpbmcuLi4nLCBzdGFja05hbWUpO1xuICByZXR1cm4gd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIHN0YWNrTmFtZSk7XG4gICAgaWYgKCFzdGFjay5leGlzdHMpIHtcbiAgICAgIGRlYnVnKCdTdGFjayAlcyBkb2VzIG5vdCBleGlzdCcsIHN0YWNrTmFtZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG4gICAgaWYgKHN0YXR1cy5pc0luUHJvZ3Jlc3MpIHtcbiAgICAgIGRlYnVnKCdTdGFjayAlcyBoYXMgYW4gb25nb2luZyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3MgYW5kIGlzIG5vdCBzdGFibGUgKCVzKScsIHN0YWNrTmFtZSwgc3RhdHVzKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrO1xuICB9KTtcbn1cblxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUGFyYW1ldGVycyB7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZSkge1xuICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJhbWV0ZXJzKHRlbXBsYXRlLlBhcmFtZXRlcnMgfHwge30pO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPikge1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBzdGFjayBwYXJhbWV0ZXJzIHRvIHBhc3MgZnJvbSB0aGUgZ2l2ZW4gZGVzaXJlZCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgdG9TdGFja1BhcmFtZXRlcnModXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPik6IFN0YWNrUGFyYW1ldGVycyB7XG4gICAgcmV0dXJuIG5ldyBTdGFja1BhcmFtZXRlcnModGhpcy5wYXJhbXMsIHVwZGF0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZyb20gdGhlIHRlbXBsYXRlLCB0aGUgZ2l2ZW4gZGVzaXJlZCB2YWx1ZXMgYW5kIHRoZSBjdXJyZW50IHZhbHVlcywgY2FsY3VsYXRlIHRoZSBjaGFuZ2VzIHRvIHRoZSBzdGFjayBwYXJhbWV0ZXJzXG4gICAqXG4gICAqIFdpbGwgdGFrZSBpbnRvIGFjY291bnQgcGFyYW1ldGVycyBhbHJlYWR5IHNldCBvbiB0aGUgdGVtcGxhdGUgKHdpbGwgZW1pdFxuICAgKiAnVXNlUHJldmlvdXNWYWx1ZTogdHJ1ZScgZm9yIHRob3NlIHVubGVzcyB0aGUgdmFsdWUgaXMgY2hhbmdlZCksIGFuZCB3aWxsXG4gICAqIHRocm93IGlmIHBhcmFtZXRlcnMgd2l0aG91dCBhIERlZmF1bHQgdmFsdWUgb3IgYSBQcmV2aW91cyB2YWx1ZSBhcmUgbm90XG4gICAqIHN1cHBsaWVkLlxuICAgKi9cbiAgcHVibGljIGRpZmYodXBkYXRlczogUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgdW5kZWZpbmVkPiwgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBTdGFja1BhcmFtZXRlcnMge1xuICAgIHJldHVybiBuZXcgU3RhY2tQYXJhbWV0ZXJzKHRoaXMucGFyYW1zLCB1cGRhdGVzLCBwcmV2aW91c1ZhbHVlcyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN0YWNrUGFyYW1ldGVycyB7XG4gIC8qKlxuICAgKiBUaGUgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSBDcmVhdGVTdGFjayBvciBVcGRhdGVTdGFjayBBUElcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBhcGlQYXJhbWV0ZXJzOiBDbG91ZEZvcm1hdGlvbi5QYXJhbWV0ZXJbXSA9IFtdO1xuXG4gIHByaXZhdGUgX2NoYW5nZXMgPSBmYWxzZTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHBhcmFtczogUmVjb3JkPHN0cmluZywgVGVtcGxhdGVQYXJhbWV0ZXI+LFxuICAgIHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4sXG4gICAgcHJldmlvdXNWYWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fSkge1xuXG4gICAgY29uc3QgbWlzc2luZ1JlcXVpcmVkID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgW2tleSwgcGFyYW1dIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMucGFyYW1zKSkge1xuICAgICAgLy8gSWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGFyZSBTU00gcGFyYW1ldGVycywgdGhleSB3aWxsIGFsd2F5cyBsZWFkIHRvIGEgY2hhbmdlXG4gICAgICBpZiAocGFyYW0uVHlwZS5zdGFydHNXaXRoKCdBV1M6OlNTTTo6UGFyYW1ldGVyOjonKSkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSBpbiB1cGRhdGVzICYmIHVwZGF0ZXNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB1cGRhdGVzW2tleV0gfSk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZWQgdmFsdWUgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUsIHRoaXMgd2lsbCBsZWFkIHRvIGEgY2hhbmdlXG4gICAgICAgIGlmICghKGtleSBpbiBwcmV2aW91c1ZhbHVlcykgfHwgdXBkYXRlc1trZXldICE9PSBwcmV2aW91c1ZhbHVlc1trZXldKSB7XG4gICAgICAgICAgdGhpcy5fY2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHByZXZpb3VzVmFsdWVzKSB7XG4gICAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFVzZVByZXZpb3VzVmFsdWU6IHRydWUgfSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtLkRlZmF1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaXNzaW5nUmVxdWlyZWQucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtaXNzaW5nUmVxdWlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIENsb3VkRm9ybWF0aW9uIFBhcmFtZXRlcnMgYXJlIG1pc3NpbmcgYSB2YWx1ZTogJHttaXNzaW5nUmVxdWlyZWQuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICAvLyBKdXN0IGFwcGVuZCBhbGwgc3VwcGxpZWQgb3ZlcnJpZGVzIHRoYXQgYXJlbid0IHJlYWxseSBleHBlY3RlZCAodGhpc1xuICAgIC8vIHdpbGwgZmFpbCBDRk4gYnV0IG1heWJlIHBlb3BsZSBtYWRlIHR5cG9zIHRoYXQgdGhleSB3YW50IHRvIGJlIG5vdGlmaWVkXG4gICAgLy8gb2YpXG4gICAgY29uc3QgdW5rbm93blBhcmFtID0gKFtrZXksIF9dOiBbc3RyaW5nLCBhbnldKSA9PiB0aGlzLnBhcmFtc1trZXldID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzVmFsdWUgPSAoW18sIHZhbHVlXTogW3N0cmluZywgYW55XSkgPT4gISF2YWx1ZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh1cGRhdGVzKS5maWx0ZXIodW5rbm93blBhcmFtKS5maWx0ZXIoaGFzVmFsdWUpKSB7XG4gICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBQYXJhbWV0ZXJWYWx1ZTogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBzZXQgb2YgcGFyYW1ldGVyIHVwZGF0ZXMgd2lsbCBjaGFuZ2UgdGhlIGFjdHVhbCBzdGFjayB2YWx1ZXNcbiAgICovXG4gIHB1YmxpYyBnZXQgY2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlcztcbiAgfVxufSJdfQ==