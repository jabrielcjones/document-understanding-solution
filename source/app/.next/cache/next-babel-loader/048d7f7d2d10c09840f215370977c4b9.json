{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport { ascend, either, flatten, indexBy, is, isEmpty, isNil, lensPath, multiply, path, pipe, prop, range, reject, sortBy, sortWith, view, memoizeWith } from 'ramda';\nimport { COMPREHEND_MEDICAL_SERVICE, COMPREHEND_SERVICE } from './dus-constants'; // Location of Blocks within a document object\n\nconst lensDocumentBlocks = lensPath(['textractResponse', 'Blocks']); // Location of page count within single/multi page document\n\nconst lensPageCount = lensPath(['textractResponse', 'DocumentMetadata', 'Pages']);\nconst lensMultiPageCount = lensPath(['textractResponse', 0, 'DocumentMetadata', 'Pages']);\n/**\n * Get a PAGE block by page number\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber A page number\n * @return {Object}\n */\n\nfunction getPage(document, pageNumber) {\n  const blocks = getDocumentBlocks(document);\n  const pageBlocks = blocks.filter(({\n    BlockType,\n    Page\n  }) => // Single page docs only have one PAGE, and it doesn't include a Page prop\n  BlockType === 'PAGE' && (Page === pageNumber || pageNumber === 1 && !Page));\n  return isEmpty(pageBlocks) ? {} : pageBlocks[0];\n}\n/**\n * Get all Blocks for a given document.\n * @param {Object} document A Textract document object\n * @return {Array}\n */\n\n\nfunction getDocumentBlocks(document) {\n  if (either(isNil, isEmpty)(document) || !document.textractResponse) return [];\n  const isChunkedResponse = is(Array, document.textractResponse);\n  const combinedChunks = isChunkedResponse && document.textractResponse.reduce((accumulator, {\n    Blocks\n  }) => accumulator.concat(Blocks), []);\n  return isChunkedResponse ? combinedChunks : view(lensDocumentBlocks, document) || [];\n}\n/**\n * Get all Blocks for a given document, in an object indexed by ID\n * @param {Object} document A Textract document object\n * @return {Object}\n */\n\n\nfunction getIndexedDocumentBlocks(document) {\n  const blocks = getDocumentBlocks(document);\n  const indexedBlocks = indexBy(prop('Id'), blocks);\n  return indexedBlocks;\n}\n/**\n * Memoized version of the above, since indexing blocks by ID is a\n * common and very expensive task on very large documents\n */\n\n\nconst memoizedGetIndexedBlocks = memoizeWith(doc => [doc.id, doc.textractFetchedAt].join(), getIndexedDocumentBlocks);\n/**\n * Get a list of Blocks matching the IDs provided.\n * @param {Object} document A Textract document object\n * @param {Array} ids An array of Block IDs to get\n * @return {Array}\n */\n\nfunction getDocumentBlocksByIds(document, ids) {\n  const indexedBlocks = memoizedGetIndexedBlocks(document);\n  return ids.reduce((accumulator, current) => {\n    return indexedBlocks[current] ? [...accumulator, indexedBlocks[current]] : accumulator;\n  }, []);\n}\n/**\n * Get text/boolean content of VALUE or CELL Blocks.\n * @param {Object} document A Textract document object\n * @param {Array} ids An array of Block IDs\n * @return {Boolean|String}\n */\n\n\nfunction getCellOrValueContents(document, ids) {\n  if (!ids) return '';\n  const contentBlocks = getDocumentBlocksByIds(document, ids);\n  let isCheckbox = false;\n  const value = contentBlocks.map(({\n    Text,\n    BlockType,\n    SelectionStatus\n  }) => {\n    if (BlockType === 'SELECTION_ELEMENT') isCheckbox = true;\n    return BlockType === 'WORD' ? Text : SelectionStatus === 'SELECTED';\n  }); // If the value is a checkbox, we want to retain it as a boolean value\n  // instead of joining it, which converts it to a string\n\n  return isCheckbox ? value[0] ? 'Yes' : 'No' : value.join(' ');\n}\n/**\n * Get a page's child Blocks of a given type.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber A page number\n * @param {String} type A BlockType\n * @return {Array}\n */\n\n\nfunction getPageChildrenByType(document, pageNumber, type) {\n  const Relationships = prop('Relationships', getPage(document, pageNumber)) || [];\n  const childBlockIds = path([0, 'Ids'], Relationships) || [];\n  const children = getDocumentBlocksByIds(document, childBlockIds);\n  const filteredChildren = type ? filterBlocksByType(children, type) : children;\n  return filteredChildren;\n}\n/**\n * Get test from a list of LINE Blocks\n * @param {Array} blocks An array of LINE Blocks\n * @return {Array}\n */\n\n\nfunction transformLineBlocksToText(blocks) {\n  return blocks.map(({\n    Text\n  }) => Text);\n}\n/**\n * Filter a list of Blocks with a given BlockType.\n * @param {Array} blocks An array of Blocks\n * @param {String} type A BlockType\n * @return {Array}\n */\n\n\nfunction filterBlocksByType(blocks, type) {\n  return blocks.filter(({\n    BlockType\n  }) => BlockType === type);\n}\n/**\n * Get the total number of pages in a document.\n * @param {Object} document A Textract document object\n * @return {Number}\n */\n\n\nexport function getDocumentPageCount(document) {\n  const isChunkedResponse = is(Array, document.textractResponse);\n  return view(isChunkedResponse ? lensMultiPageCount : lensPageCount, document);\n}\nexport function getDocumentLines(document) {\n  const totalPages = getDocumentPageCount(document);\n  const linesByPage = range(1, totalPages + 1).map(pageNumber => {\n    const lines = getPageLines(document, pageNumber);\n    return lines;\n  });\n  return flatten(linesByPage);\n}\n/**\n * Get lines of text found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getPageLines(document, pageNumber) {\n  const lines = getPageChildrenByType(document, pageNumber, 'LINE');\n  return lines.map(({\n    Text,\n    Geometry,\n    Page\n  }) => {\n    return {\n      text: Text,\n      pageNumber: Page,\n      boundingBox: Geometry.BoundingBox\n    };\n  });\n}\nexport function getDocumentBlocksByType(document, type) {\n  const blocks = getDocumentBlocks(document);\n  return filterBlocksByType(blocks, type);\n}\nexport function countDocumentKeyValuePairs(document) {\n  const keyValueSetBlocks = getDocumentBlocksByType(document, 'KEY_VALUE_SET'); // Filter those down to get the blocks of EntityType KEY\n  // NOTE: EntityTypes is an array, even though it only ever contains one value\n\n  const keyBlocks = keyValueSetBlocks.filter(({\n    EntityTypes\n  }) => EntityTypes.indexOf('KEY') >= 0);\n  return keyBlocks.length;\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getDocumentKeyValuePairs(document) {\n  const totalPages = getDocumentPageCount(document);\n  const blocksByPage = range(1, totalPages + 1).map(pageNumber => {\n    const blocks = getPageKeyValuePairs(document, pageNumber);\n    return blocks.map(b => {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber\n      });\n    });\n  });\n  return flatten(blocksByPage);\n}\n/**\n * Get entities found in a page.\n * @param {Object} document A Comprehend document object\n * @param {String} comprehendService The comprehend Service being used : Comprehend/ComprehendMedical\n * @return {Array}\n */\n\nexport function getDocumentEntityPairs(document, comprehendService) {\n  const totalPages = getDocumentPageCount(document);\n  let MERGE_KEY = null;\n\n  if (comprehendService == COMPREHEND_MEDICAL_SERVICE) {\n    MERGE_KEY = 'Category';\n  } else {\n    MERGE_KEY = 'Type';\n  }\n\n  const blocksByPage = range(1, totalPages + 1).map(pageNumber => {\n    const blocks = getPageEntityPairs(document, pageNumber, comprehendService);\n    const entity_array = consolidateDictionaryList(blocks[\"Entities\"], MERGE_KEY, \"Text\");\n    return entity_array.map(b => {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber\n      });\n    });\n  });\n  return isEmpty(blocksByPage) ? [] : [].concat.apply([], blocksByPage);\n}\nexport function consolidateDictionaryList(dictionaryList, mergeKey, mergeValue) {\n  let output = [];\n  let entity_object = {};\n  let processing_dict = {};\n  dictionaryList.forEach(function (item) {\n    if (!(item[mergeKey] in processing_dict)) {\n      processing_dict[item[mergeKey]] = new Set();\n    }\n\n    processing_dict[item[mergeKey]].add(item[mergeValue]);\n  });\n  const entityDictKeys = Object.keys(processing_dict);\n\n  for (const key of entityDictKeys) {\n    entity_object[\"entity\"] = key;\n    entity_object[\"value\"] = [...processing_dict[key]];\n    output.push(entity_object);\n    entity_object = {};\n  }\n\n  return output;\n}\nexport function resetFormsonPage() {\n  let formsCollection = document.forms;\n\n  for (let i = 0; i < formsCollection.length; i++) {\n    formsCollection[i].reset();\n  }\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Comprehend/Comprehend Medical document object\n * @param {Number} pageNumber The page number to get results for\n * @param {String} comprehendService The comprehend service used : Comprehend/ComprehendMedical\n * @return {Array}\n */\n\nexport function getPageEntityPairs(document, pageNumber, comprehendService) {\n  // Get all blocks of Entities for a PAGE\n  let blocks = [];\n\n  if (comprehendService == COMPREHEND_MEDICAL_SERVICE) {\n    blocks = document.comprehendMedicalRespone[\"results\"];\n  } else {\n    blocks = document.comprehendRespone[\"results\"];\n  }\n\n  const pageBlocks = blocks.filter(({\n    Entities,\n    Page\n  }) => // Single page docs only have one PAGE, and it doesn't include a Page prop\n  Page === pageNumber);\n  return isEmpty(pageBlocks) ? {} : pageBlocks[0];\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getPageKeyValuePairs(document, pageNumber) {\n  // Get all blocks of BlockType KEY_VALUE_SET for a PAGE\n  const keyValueSetBlocks = getPageChildrenByType(document, pageNumber, 'KEY_VALUE_SET'); // Filter those down to get the blocks of EntityType KEY\n  // NOTE: EntityTypes is an array, even though it only ever contains one value\n\n  const keyBlocks = keyValueSetBlocks.filter(({\n    EntityTypes\n  }) => EntityTypes.indexOf('KEY') >= 0); // Iterate over each KEY block\n\n  const pairs = keyBlocks.map(({\n    Id,\n    Relationships,\n    Geometry\n  }) => {\n    // Get related VALUE blocks and WORD blocks for this KEY block\n    const valueBlockIds = path([0, 'Ids'], Relationships) || [];\n    const keyWordIds = path([1, 'Ids'], Relationships) || [];\n    const keyWordBlocks = getDocumentBlocksByIds(document, keyWordIds);\n    const valueBlocks = getDocumentBlocksByIds(document, valueBlockIds); // Get WORD blocks for each VALUE block\n\n    const valueWordIds = valueBlocks.reduce((accumulator, {\n      Relationships\n    }) => {\n      const childIds = Relationships ? Relationships[0].Ids : [];\n      return [...accumulator, ...childIds];\n    }, []); // Finally, return a simple object containing joined KEY and VALUE words\n\n    const key = keyWordBlocks.map(({\n      Text\n    }) => Text).join(' ');\n    const value = getCellOrValueContents(document, valueWordIds);\n    return {\n      id: Id,\n      key,\n      value,\n      keyBoundingBox: Geometry.BoundingBox,\n      valueBoundingBox: valueBlocks[0].Geometry.BoundingBox\n    };\n  });\n  return sortBy(x => x.keyBoundingBox.Top + 0.05 * x.keyBoundingBox.Left)(pairs.filter(p => p.key || p.value));\n}\nexport function getDocumentTables(document) {\n  const totalPages = getDocumentPageCount(document);\n  const blocksByPage = range(1, totalPages + 1).map(pageNumber => {\n    const blocks = getPageTables(document, pageNumber);\n    return blocks.map(b => {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber\n      });\n    });\n  });\n  return isEmpty(blocksByPage) ? [] : [].concat.apply([], blocksByPage);\n}\n/**\n * Get tables/rows/cells found in a page.\n * @param {Number} pageNumber The page number to get results for\n * @param {Object} document A Textract document object\n * @return {Array}\n */\n\nexport function getPageTables(document, pageNumber) {\n  // Get all blocks of BlockType TABLE for a PAGE\n  const tableBlocks = getPageChildrenByType(document, pageNumber, 'TABLE'); // Iterate each TABLE in order to build a new data structure\n\n  const tables = tableBlocks.map(table => {\n    const {\n      Relationships\n    } = table; // Get all blocks of BlockType CELL within this TABLE\n\n    const cellBlockIds = path([0, 'Ids'], Relationships) || [];\n    const cellBlocks = getDocumentBlocksByIds(document, cellBlockIds); // Iterate each CELL in order to build an array for each row containing an object for each cell\n\n    const rowData = cellBlocks.reduce((accumulator, current) => {\n      const {\n        RowIndex,\n        ColumnIndex,\n        RowSpan,\n        ColumnSpan,\n        Relationships,\n        Geometry\n      } = current;\n      const contentBlockIds = path([0, 'Ids'], Relationships) || [];\n      const row = accumulator[RowIndex - 1] || [];\n      row[ColumnIndex - 1] = {\n        RowIndex,\n        ColumnIndex,\n        RowSpan,\n        ColumnSpan,\n        content: getCellOrValueContents(document, contentBlockIds),\n        Geometry\n      };\n      accumulator[RowIndex - 1] = row;\n      return accumulator;\n    }, []);\n    return {\n      table,\n      rows: rowData\n    };\n  });\n  return tables;\n}\nexport function getMultiPageWordsBySearch(document, pageNumber, wordList) {\n  let output = [];\n  wordList.forEach(function (item) {\n    output.push(...getPageWordsBySearch(document, pageNumber, item));\n  });\n  return output;\n}\n/**\n * Get WORD blocks that match a search query on a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @param {String} searchQuery The string to find in the document\n * @return {Array}\n */\n\nexport function getPageWordsBySearch(document, pageNumber, searchQuery) {\n  if (!searchQuery) return [];\n  const searchQueryWords = reject(isEmpty, searchQuery.split(' '));\n\n  function escapeRegex(str) {\n    return str.replace(/[-[\\]{}()*+?.,\\\\^$|]/g, '\\\\$&');\n  }\n\n  const searchQueryRegex = RegExp(escapeRegex(searchQuery), 'i'); // Get all the LINE Blocks for a PAGE that match the searchQuery\n\n  const lines = getPageChildrenByType(document, pageNumber, 'LINE');\n  const matchingLines = lines.filter(({\n    Text\n  }) => searchQueryRegex.test(Text)); // Get all the WORD Blocks for each LINE that match the searchQuery\n\n  const matchingWords = matchingLines.reduce((accumulator, {\n    Relationships\n  }) => {\n    const wordIds = path([0, 'Ids'], Relationships) || []; // Sort all the WORD Blocks in order from left to right\n\n    const wordBlocks = sortWith([ascend(path(['Geometry', 'BoundingBox', 'Left']))])(getDocumentBlocksByIds(document, wordIds));\n    const wordText = wordBlocks.map(word => word.Text).join(' ');\n    const matchRegexp = RegExp(escapeRegex(searchQueryWords.join(' ')), 'ig');\n    let res;\n\n    function getWordIndexByStringIndex(idx) {\n      let searchIndex = 0;\n      let wordIndex;\n\n      for (wordIndex = 0; wordIndex < wordBlocks.length; wordIndex++) {\n        const word = wordBlocks[wordIndex];\n        if (idx < searchIndex + word.Text.length + 1) return wordIndex;\n        searchIndex += word.Text.length + 1;\n      }\n\n      return wordIndex;\n    }\n\n    const matchingWordBlocks = [];\n\n    while ((res = matchRegexp.exec(wordText)) !== null) {\n      const startIndex = res.index;\n      const endIndex = startIndex + res[0].length;\n      const startWord = getWordIndexByStringIndex(startIndex);\n      const endWord = getWordIndexByStringIndex(endIndex);\n\n      for (let i = startWord; i <= endWord; i++) {\n        if (!matchingWordBlocks.includes(wordBlocks[i])) matchingWordBlocks.push(wordBlocks[i]);\n      }\n    } // TODO most of the below logic can probably be removed / consolidated into the above\n    // Pick specific props from each WORD Block\n\n\n    const matchingWordBounds = matchingWordBlocks.map(({\n      Text,\n      Geometry: {\n        BoundingBox: {\n          Top,\n          Left,\n          Width,\n          Height\n        }\n      }\n    }) => ({\n      Text,\n      Top,\n      Left,\n      Width,\n      Height\n    })); // Sort all the words by their location from top/left to bottom/right\n\n    const matchingWordBoundsSorted = sortWith([({\n      Top: a\n    }, {\n      Top: b\n    }) => {\n      const difference = pipe(Math.abs, multiply(100), Math.floor)(a - b);\n      return !difference ? 0 : a < b ? -1 : a > b ? 1 : 0;\n    }, ascend(path(['Left']))])(matchingWordBounds); // Combine words together such that they match the query (and merge their bounding box info)\n\n    let unmatched = null;\n    const matchingWordBoundsCombined = matchingWordBoundsSorted.reduce((accumulator, word) => {\n      const wordMatches = searchQueryRegex.test(word.Text); // If a single word matches the query, add it to the list\n\n      if (wordMatches) {\n        unmatched = null;\n        return [...accumulator, word];\n      } // If there's an unmatched word from a previous iteration,\n      // see if combining the two will match the query\n\n\n      if (unmatched) {\n        const combinedText = `${unmatched.Text} ${word.Text}`;\n        const combinedWords = {\n          Text: combinedText,\n          Top: Math.max(unmatched.Top, word.Top),\n          Left: Math.min(unmatched.Left, word.Left),\n          Width: word.Left - unmatched.Left + word.Width,\n          Height: Math.max(unmatched.Height, word.Height)\n        };\n        const combinedWordsMatch = searchQueryRegex.test(combinedText); // If the combined words match the query, add it to the list\n\n        if (combinedWordsMatch) {\n          unmatched = null;\n          return [...accumulator, combinedWords];\n        } // Otherwise, update unmatched with the combined words object\n\n\n        unmatched = combinedWords;\n      } else {\n        // If there wasn't an unmatched word from a previous iteration, set unmatched\n        unmatched = word;\n      }\n\n      return accumulator;\n    }, []);\n    return accumulator.concat(matchingWordBoundsCombined);\n  }, []);\n  return matchingWords;\n}","map":null,"metadata":{},"sourceType":"module"}