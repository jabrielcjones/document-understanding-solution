{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport React, { useCallback, useEffect, useState, Fragment } from 'react';\nimport { connect } from 'react-redux';\nimport classNames from 'classnames';\nimport { Storage } from 'aws-amplify';\nimport { useDropzone } from 'react-dropzone';\nimport { format } from 'date-fns';\nimport uuid from \"uuid/v4\";\nimport getConfig from \"next/config\";\nimport Button from '../Button/Button';\nimport Modal from '../Modal/Modal';\nimport { useContext } from 'react';\nimport ModalContext from '../ModalContext/ModalContext';\nimport CameraCapture from '../CameraCapture/CameraCapture';\nimport { submitDocument } from '../../store/entities/documents/actions';\nimport { clearSearchQuery } from '../../store/entities/meta/actions';\nimport css from './FileUpload.scss';\nconst {\n  publicRuntimeConfig: {\n    isROMode\n  }\n} = getConfig();\n\nfunction FileUpload({\n  dispatch\n}) {\n  const {\n    0: canUseCamera,\n    1: setCanUseCamera\n  } = useState({});\n  const {\n    0: cameraCapturing,\n    1: setCameraCapturing\n  } = useState(false);\n  const {\n    0: fileStatus,\n    1: setFileStatus\n  } = useState({});\n  const {\n    0: uploadStatus,\n    1: setUploadStatus\n  } = useState('');\n  const {\n    0: files,\n    1: setFiles\n  } = useState({});\n  const {\n    modal,\n    setModal\n  } = isROMode === \"true\" ? useContext(ModalContext) : useState('');\n  const fileNames = Object.keys(files); // Aggregate upload statuses\n\n  const isUploadPending = uploadStatus === 'pending';\n  const isUploadSuccessful = uploadStatus === 'success';\n  const isUploadFailed = uploadStatus === 'error';\n  const isReadyToUpload = !uploadStatus;\n  useEffect(() => {\n    const md = window.navigator && navigator.mediaDevices;\n\n    if (!md || !md.enumerateDevices) {\n      setCanUseCamera(false);\n    } else {\n      md.enumerateDevices().then(devices => {\n        setCanUseCamera(devices.some(device => device.kind === 'videoinput'));\n      });\n    }\n  }, []); // Configure dropzone\n\n  const onDrop = useCallback(acceptedFiles => {\n    if (isROMode === 'true') {\n      setModal(true);\n    } else {\n      const fileMap = {};\n      setUploadStatus('');\n      acceptedFiles.forEach(file => {\n        fileMap[file.name] = file;\n      });\n      setFiles(files => _objectSpread(_objectSpread({}, files), fileMap));\n    }\n  }, []);\n  const {\n    getRootProps,\n    getInputProps,\n    isDragActive\n  } = useDropzone({\n    onDrop,\n    disabled: !isReadyToUpload\n  });\n  /**\n  * Handle clicks on the select documents CTA when the mode is Demonstration Mode\n  *\n  */\n\n  const handleSelectDocumentsClickDemoOnly = useCallback(() => {\n    setModal(true);\n  }, []); // Dynamic class names\n\n  const fileUploadClassNames = classNames(css.fileUpload, {\n    [css.dragActive]: isDragActive\n  });\n  /**\n   * Click handler for upload button\n   */\n\n  const handleUploadClick = useCallback(() => {\n    // Set aggregate status\n    setUploadStatus('pending'); // Upload files\n\n    const uploads = uploadFiles({\n      fileNames,\n      files,\n\n      onProgress({\n        fileName,\n        progress\n      }) {\n        setFileStatus(fileStatus => _objectSpread(_objectSpread({}, fileStatus), {\n          [fileName]: {\n            progress: `${Math.min(Math.round(progress.loaded / progress.total * 100), 99)}%`\n          }\n        }));\n      },\n\n      onSuccess({\n        result,\n        fileName\n      }) {\n        return dispatch(submitDocument({\n          key: `public/${result.key}`\n        })).then(() => {\n          setFileStatus(fileStatus => _objectSpread(_objectSpread({}, fileStatus), {\n            [fileName]: {\n              success: true\n            }\n          }));\n        });\n      },\n\n      onError({\n        fileName\n      }) {\n        setFileStatus(fileStatus => _objectSpread(_objectSpread({}, fileStatus), {\n          [fileName]: {\n            error: true\n          }\n        }));\n      }\n\n    }); // Set aggregate status based on result of upload promises\n\n    Promise.all(uploads).then(() => {\n      dispatch(clearSearchQuery());\n      setUploadStatus('success');\n    }).catch(error => {\n      setUploadStatus('error');\n    });\n  }, [dispatch, fileNames, files]);\n  /**\n   * Delete a file\n   *\n   * @param {String} fileName The name of the file to delete\n   */\n\n  function deleteFile(fileName) {\n    setFiles((_ref) => {\n      let files = Object.assign({}, _ref);\n      return delete files[fileName] && files;\n    });\n  }\n\n  const startCamera = useCallback(() => {\n    setCameraCapturing(true);\n  }, []);\n  const cameraCaptured = useCallback(blob => {\n    setCameraCapturing(false);\n    const datestring = format(new Date(), 'YYYYMMDDHHmmss');\n    const filename = `cameracapture-${datestring}.jpg`;\n    setFiles(files => _objectSpread(_objectSpread({}, files), {}, {\n      [filename]: blob\n    }));\n  }, []);\n\n  if (isROMode === \"true\") {\n    return __jsx(\"div\", null, __jsx(\"div\", getRootProps({\n      className: fileUploadClassNames,\n      onClick: handleSelectDocumentsClickDemoOnly,\n      tabIndex: -1\n    }), __jsx(\"input\", getInputProps({\n      disabled: true\n    })), __jsx(\"img\", {\n      src: \"/static/images/icon_file-upload.svg\",\n      alt: \"File Upload Icon\"\n    }), isDragActive && __jsx(\"p\", {\n      className: css.instructions\n    }, \"Drop the documents here...\"), !isDragActive && isReadyToUpload && __jsx(React.Fragment, null, __jsx(\"p\", {\n      className: css.instructions\n    }, \"Drag and drop files or \", __jsx(\"em\", {\n      tabIndex: \"0\"\n    }, \"Choose documents\")), isReadyToUpload && __jsx(\"p\", {\n      className: css.limits\n    }, \"Accepts JPG/PNG (max 5MB) and PDF (max 150 MB, max 200 pages)\"), canUseCamera && __jsx(\"p\", {\n      className: css.instructions\n    }, \"or \", __jsx(Button, {\n      onClick: () => setModal(true)\n    }, \"use your camera\")))));\n  } else {\n    return __jsx(\"div\", getRootProps({\n      className: fileUploadClassNames,\n      onClick: handleSelectDocumentsClick,\n      tabIndex: -1\n    }), __jsx(\"input\", getInputProps()), __jsx(\"img\", {\n      src: \"/static/images/icon_file-upload.svg\",\n      alt: \"File Upload Icon\"\n    }), isDragActive && __jsx(\"p\", {\n      className: css.instructions\n    }, \"Drop the documents here...\"), !isDragActive && isReadyToUpload && __jsx(React.Fragment, null, __jsx(\"p\", {\n      className: css.instructions\n    }, \"Drag and drop files or \", __jsx(\"em\", {\n      tabIndex: \"0\"\n    }, \"Choose documents\")), isReadyToUpload && __jsx(\"p\", {\n      className: css.limits\n    }, \"Accepts JPG/PNG (max 5MB) and PDF (max 150 MB, max 200 pages)\"), canUseCamera && __jsx(\"p\", {\n      className: css.instructions\n    }, \"or \", __jsx(Button, {\n      onClick: startCamera\n    }, \"use your camera\"))), isUploadPending && __jsx(\"p\", {\n      className: css.instructions\n    }, \"Uploading...\"), isUploadSuccessful && __jsx(\"p\", {\n      className: css.instructions\n    }, \"Done!\"), isUploadFailed && __jsx(\"p\", {\n      className: css.instructions\n    }, \"Something went wrong, please refresh and try again.\"), !!fileNames.length && __jsx(Fragment, null, __jsx(\"ul\", null, fileNames.map(fileName => {\n      const status = fileStatus[fileName] || {};\n      const {\n        success,\n        error,\n        progress\n      } = status;\n      return __jsx(\"li\", {\n        key: fileName\n      }, isReadyToUpload && __jsx(\"img\", {\n        src: \"/static/images/icon_document.svg\",\n        alt: \"Document Icon\"\n      }), !success && !error && progress && __jsx(\"span\", null, progress), success && __jsx(\"img\", {\n        src: \"/static/images/icon_success.svg\",\n        alt: \"Success Icon\"\n      }), error && __jsx(\"img\", {\n        src: \"/static/images/icon_error.svg\",\n        alt: \"Error Icon\"\n      }), fileName, isReadyToUpload && __jsx(\"svg\", {\n        height: \"24\",\n        viewBox: \"0 0 24 24\",\n        width: \"24\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        onClick: () => deleteFile(fileName)\n      }, __jsx(\"path\", {\n        d: \"m12 10.5857864 5.2928932-5.29289318c.3905243-.39052429 1.0236893-.39052429 1.4142136 0s.3905243 1.02368927 0 1.41421356l-5.2928932 5.29289322 5.2928932 5.2928932c.3905243.3905243.3905243 1.0236893 0 1.4142136s-1.0236893.3905243-1.4142136 0l-5.2928932-5.2928932-5.29289322 5.2928932c-.39052429.3905243-1.02368927.3905243-1.41421356 0s-.39052429-1.0236893 0-1.4142136l5.29289318-5.2928932-5.29289318-5.29289322c-.39052429-.39052429-.39052429-1.02368927 0-1.41421356s1.02368927-.39052429 1.41421356 0z\"\n      })));\n    })), isReadyToUpload && __jsx(Button, {\n      inverted: true,\n      onClick: handleUploadClick\n    }, \"Upload\"), !isReadyToUpload && __jsx(Button, {\n      inverted: true,\n      disabled: !isUploadSuccessful,\n      link: {\n        href: '/documents'\n      }\n    }, \"Continue\")), cameraCapturing && __jsx(CameraCapture, {\n      onCapture: cameraCaptured,\n      onCancel: () => setCameraCapturing(false)\n    }));\n  }\n}\n\nexport default connect()(FileUpload);\n\nasync function isUUIdPresentInS3(documentUUID) {\n  var s3ListPromise = Storage.list(`${documentUUID}/`).then(result => {\n    return result;\n  });\n  let s3Result = await s3ListPromise;\n  return s3Result.length > 0;\n}\n\nasync function getUniqueDocumentId() {\n  let documentUUID = uuid();\n\n  if (await isUUIdPresentInS3(documentUUID)) {\n    return getUniqueDocumentId();\n  } else {\n    return documentUUID;\n  }\n}\n/**\n * Upload files to S3. NOTE: Amplify does not allow you to upload multiple files\n * in a single call, which is why this function runs a loop to make a call for each file.\n *\n * @param {Object}   config             An object of configs\n * @param {Array}    config.fileNames   An array of file names\n * @param {Object}   config.files       An object of files where the keys are the file names\n * @param {Function} config.onSuccess   A callback that fires on success of a single upload\n * @param {Function} config.onError     A callback that fires on error of a single upload\n * @param {Function} config.onProgress  A callback that fires on progress of a single upload\n */\n\n\nfunction uploadFiles({\n  fileNames = [],\n  files = {},\n  onSuccess,\n  onError,\n  onProgress\n}) {\n  const fileLengthExceeded = Boolean(fileNames.length > 100);\n\n  if (fileLengthExceeded) {\n    alert(\" Supported no. of files upload limit : less than 100\");\n  }\n\n  return fileNames.map(fileName => {\n    const file = files[fileName];\n\n    if (fileLengthExceeded) {\n      return onError({\n        fileName\n      });\n    }\n\n    if (![\"application/pdf\", \"image/png\", \"image/jpeg\"].includes(file.type)) {\n      alert(fileName + \" : Supported file formats : JPG,PNG,PDF\");\n      return onError({\n        fileName\n      });\n    }\n\n    if (file.type == \"application/pdf\" && file.size / 1000000 >= 150) {\n      //Maximum File size supported is 150MB\n      alert(fileName + \" : Supported PDF size : less than 150MB\");\n      return onError({\n        fileName\n      });\n    }\n\n    if ([\"image/png\", \"image/jpeg\"].includes(file.type) && file.size / 1000000 >= 5) {\n      //Maximum File size supported is 5MB\n      alert(fileName + \" : Supported Image size : less than 5MB\");\n      return onError({\n        fileName\n      });\n    }\n\n    onProgress({\n      progress: {\n        loaded: 0,\n        total: file.size || 100\n      },\n      fileName,\n      file\n    });\n    getUniqueDocumentId().then(result => {\n      const key = [result, fileName].join('/');\n      Storage.put(key, file, {\n        progressCallback(progress) {\n          onProgress({\n            progress,\n            fileName,\n            file\n          });\n        }\n\n      }).then(result => {\n        return onSuccess({\n          result,\n          fileName,\n          file\n        });\n      }).catch(error => {\n        onError({\n          error,\n          fileName,\n          file\n        });\n        throw error;\n      });\n    });\n  });\n}\n/**\n * Handle clicks on the select documents CTA\n *\n * @param {Object} e Event object\n */\n\n\nfunction handleSelectDocumentsClick(e) {\n  e.preventDefault();\n  e.target.tagName.toLowerCase() !== 'em' && e.stopPropagation();\n}","map":null,"metadata":{},"sourceType":"module"}