{"ast":null,"code":"import _regeneratorRuntime from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport React, { Fragment, useEffect, useState, useCallback } from \"react\";\nimport App, { Container } from \"next/app\";\nimport getConfig from \"next/config\";\nimport Head from \"next/head\";\nimport Router from \"next/router\";\nimport Amplify, { Auth } from \"aws-amplify\";\nimport { times, reject, isNil } from \"ramda\";\nimport { Provider } from \"react-redux\";\nimport withRedux from \"next-redux-wrapper\";\nimport initStore from \"../store/store\";\nimport Header from \"../components/Header/Header\";\nimport { setSelectedTrack, dismissWalkthrough } from \"../store/ui/actions\";\nimport \"../styles/global.scss\";\nimport css from \"./app.scss\";\n\nvar _getConfig = getConfig(),\n    _getConfig$publicRunt = _getConfig.publicRuntimeConfig,\n    APIGateway = _getConfig$publicRunt.APIGateway,\n    bucket = _getConfig$publicRunt.bucket,\n    identityPoolId = _getConfig$publicRunt.identityPoolId,\n    region = _getConfig$publicRunt.region,\n    userPoolWebClientId = _getConfig$publicRunt.userPoolWebClientId,\n    userPoolId = _getConfig$publicRunt.userPoolId;\n\nAmplify.configure({\n  Auth: {\n    identityPoolId: identityPoolId,\n    region: region,\n    userPoolId: userPoolId,\n    userPoolWebClientId: userPoolWebClientId\n  },\n  Storage: {\n    AWSS3: {\n      bucket: bucket,\n      level: \"public\",\n      region: region\n    }\n  },\n  API: {\n    endpoints: [{\n      name: \"TextractDemoTextractAPI\",\n      endpoint: \"https://\".concat(APIGateway, \".execute-api.\").concat(region, \".amazonaws.com/prod/\")\n    }]\n  }\n}); // This is a bit of a hack to ensure styles reload on client side route changes.\n// See: https://github.com/zeit/next-plugins/issues/282#issuecomment-480740246\n\nif (false) {\n  Router.events.on(\"routeChangeComplete\", function () {\n    var path = \"/_next/static/css/styles.chunk.css\";\n    var chunksSelector = \"link[href*=\\\"\".concat(path, \"\\\"]\");\n    var chunksNodes = document.querySelectorAll(chunksSelector);\n    var timestamp = new Date().valueOf();\n    chunksNodes[0].href = \"\".concat(path, \"?\").concat(timestamp);\n  });\n}\n\nvar AppLayout = /*#__PURE__*/function (_App) {\n  _inherits(AppLayout, _App);\n\n  var _super = _createSuper(AppLayout);\n\n  function AppLayout() {\n    _classCallCheck(this, AppLayout);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(AppLayout, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // Set selected track from localStorage\n      // This allows you to hard refresh a page and maintain some state\n      if (localStorage) {\n        var store = this.props.store;\n        var cachedTrack = localStorage.getItem(\"track\");\n        if (cachedTrack) store.dispatch(setSelectedTrack(cachedTrack));\n        var previouslyDismissedWalkthrough = localStorage.getItem(\"dismissedWalkthrough\");\n        if (previouslyDismissedWalkthrough) store.dispatch(dismissWalkthrough());\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          Component = _this$props.Component,\n          pageProps = _this$props.pageProps,\n          pathname = _this$props.pathname,\n          store = _this$props.store;\n      var pageTitle = pageProps.pageTitle; // Don't render the app unless the user is logged in or this is a public route.\n\n      return __jsx(Provider, {\n        store: store\n      }, __jsx(Head, null, __jsx(\"title\", null, pageTitle ? \"\".concat(pageTitle, \" | DUS \") : \"DUS\"), __jsx(\"link\", {\n        rel: \"icon\",\n        type: \"image/ico\",\n        href: \"/static/images/favicon.ico\"\n      }), __jsx(\"link\", {\n        rel: \"shortcut icon\",\n        type: \"image/ico\",\n        href: \"/static/images/favicon.ico\"\n      }), __jsx(\"link\", {\n        rel: \"apple-touch-icon\",\n        sizes: \"57x57\",\n        href: \"/static/images/touch-icon-iphone-114-smile.png\"\n      }), __jsx(\"link\", {\n        rel: \"apple-touch-icon\",\n        sizes: \"72x72\",\n        href: \"/static/images/touch-icon-ipad-144-smile.png\"\n      }), __jsx(\"link\", {\n        rel: \"apple-touch-icon\",\n        sizes: \"114x114\",\n        href: \"/static/images/touch-icon-iphone-114-smile.png\"\n      }), __jsx(\"link\", {\n        rel: \"apple-touch-icon\",\n        sizes: \"144x144\",\n        href: \"/static/images/touch-icon-ipad-144-smile.png\"\n      })), __jsx(Page, {\n        pathname: pathname,\n        pageProps: pageProps\n      }, __jsx(Component, pageProps)));\n    }\n  }], [{\n    key: \"getInitialProps\",\n    value: function () {\n      var _getInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n        var Component, ctx, pageProps, pathname;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                Component = _ref.Component, ctx = _ref.ctx;\n                pageProps = {};\n                pathname = ctx.pathname;\n\n                if (!Component.getInitialProps) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 6;\n                return Component.getInitialProps(ctx);\n\n              case 6:\n                pageProps = _context.sent;\n\n              case 7:\n                return _context.abrupt(\"return\", {\n                  pageProps: pageProps,\n                  pathname: pathname\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function getInitialProps(_x) {\n        return _getInitialProps.apply(this, arguments);\n      }\n\n      return getInitialProps;\n    }()\n  }]);\n\n  return AppLayout;\n}(App);\n\nfunction Page(_ref2) {\n  var children = _ref2.children,\n      pageProps = _ref2.pageProps,\n      pathname = _ref2.pathname;\n  var showNavigation = pageProps.showNavigation,\n      backButton = pageProps.backButton,\n      heading = pageProps.pageTitle;\n  var showGrid = useGridOverlay(); // All routes are protected by default. We whitelist public routes.\n  // Authorization does not occur on public routes.\n\n  var isPublicRoute = [\"/styleguide\"].indexOf(pathname) >= 0; // The Login page is technically a public route, but we handle it separately because\n  // we do an auth check on it in order to redirect if the user is already logged in.\n\n  var isLoginRoute = pathname === \"/\";\n\n  var _useState = useState(\"pending\"),\n      isLoggedIn = _useState[0],\n      setLoggedIn = _useState[1]; // Don't render the app unless the user is logged in, or this is a public route,\n  // or this is the login route and the user is not logged in.\n\n\n  var shouldRenderApp = isLoggedIn === true || isPublicRoute || isLoginRoute && !isLoggedIn; // Authorize user\n  // NOTE: This method of authorization is not sufficient to protect static content.\n  // The authorization happens on the client side only, which means all static\n  // content still gets delivered to the browser in the initial page response\n  // (even though we may not render it with React). However, all protected content\n  // in this app is delivered by API calls that have their own authorization checks.\n\n  useEffect(function () {\n    // If this is a public route, we don't need to authorize.\n    if (isPublicRoute) return; // Try to get the user's session info\n\n    Auth.currentSession().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.t0 = isLoginRoute;\n\n              if (!_context2.t0) {\n                _context2.next = 4;\n                break;\n              }\n\n              _context2.next = 4;\n              return Router.push(\"/home\");\n\n            case 4:\n              setLoggedIn(true);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))).catch(function () {\n      // No user session, redirect to login if not already there\n      setLoggedIn(false);\n      !isLoginRoute && Router.push(\"/\");\n    });\n  }, [isLoginRoute, isPublicRoute]);\n  return shouldRenderApp && __jsx(\"div\", {\n    className: css.container\n  }, __jsx(Header, reject(isNil, {\n    heading: heading,\n    showNavigation: showNavigation,\n    backButton: backButton\n  })), __jsx(\"main\", null, children), showGrid && __jsx(\"div\", {\n    className: css.gridContainer\n  }, times(function (i) {\n    return __jsx(\"div\", {\n      key: i,\n      className: css.gridCol\n    });\n  }, 12)));\n}\n/**\n * This is a helper utility that will overlay a grid on top of the app.\n * This allows us to ensure elements fall on the grid while developing.\n * (Press control + L to toggle the grid)\n */\n\n\nfunction useGridOverlay() {\n  var _useState2 = useState(false),\n      showGrid = _useState2[0],\n      setShowGrid = _useState2[1]; // Toggle grid handler\n\n\n  var handleKeyUp = useCallback(function (e) {\n    var L = 76;\n    var ctrlKey = e.ctrlKey,\n        keyCode = e.keyCode;\n\n    if (ctrlKey && keyCode === L) {\n      e.preventDefault();\n      setShowGrid(function (showGrid) {\n        return !showGrid;\n      });\n    }\n  }, []); // Add/remove event listener\n\n  useEffect(function () {\n    document.addEventListener(\"keyup\", handleKeyUp);\n    return function () {\n      document.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, [handleKeyUp]);\n  return showGrid;\n}\n\nexport default withRedux(initStore)(AppLayout);","map":null,"metadata":{},"sourceType":"module"}