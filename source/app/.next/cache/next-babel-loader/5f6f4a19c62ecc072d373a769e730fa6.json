{"ast":null,"code":"var __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport React, { Fragment, useCallback, useEffect, useRef, useState, useMemo } from 'react';\nimport { connect } from 'react-redux';\nimport { reject, either, isNil, isEmpty, groupWith } from 'ramda';\nimport queryString from 'query-string';\nimport cs from 'classnames';\nimport { Storage } from 'aws-amplify';\nimport Loading from '../../components/Loading/Loading';\nimport DocumentViewer from '../../components/DocumentViewer/DocumentViewer';\nimport DocumentSearchBar from '../../components/DocumentSearchBar/DocumentSearchBar';\nimport Tabs from '../../components/Tabs/Tabs';\nimport { fetchDocument, addRedactions, clearRedactions, addHighlights, clearHighlights } from '../../store/entities/documents/actions';\nimport { getDocumentById } from '../../store/entities/documents/selectors';\nimport { setHeaderProps, setSelectedTrack } from '../../store/ui/actions';\nimport { getSelectedTrackId } from '../../store/ui/selectors';\nimport { setCurrentPageNumber, setDocumentSearchQuery } from '../../store/entities/meta/actions';\nimport { getDocumentSearchQuery, getCurrentPageNumber } from '../../store/entities/meta/selectors';\nimport { getDocumentPageCount, getPageLines, getDocumentLines, getDocumentEntityPairs, getDocumentKeyValuePairs, getPageTables, getPageWordsBySearch, getDocumentTables } from '../../utils/document';\nimport { COMPREHEND_MEDICAL_SERVICE, COMPREHEND_SERVICE } from '../../utils/dus-constants';\nimport css from './view.scss';\nimport Button from '../../components/Button/Button';\nimport KeyValueList from '../../components/KeyValueList/KeyValueList';\nimport RawTextLines from '../../components/RawTextLines/RawTextLines';\nimport EntitiesCheckbox from '../../components/EntitiesCheckbox/EntitiesCheckbox';\nimport DocumentPreview from '../../components/DocumentPreview/DocumentPreview';\nimport TableResults from '../../components/TableResults/TableResults';\nDocument.defaultProps = {\n  document: {}\n};\n\nDocument.getInitialProps = function ({\n  query,\n  store\n}) {\n  const state = store.getState();\n  const {\n    id\n  } = query || {};\n  const {\n    documentName\n  } = getDocumentById(state, id) || {};\n  const props = {\n    showNavigation: false,\n    backButton: true\n  };\n  return props;\n};\n\nfunction Document({\n  currentPageNumber,\n  dispatch,\n  id,\n  document,\n  pageTitle,\n  searchQuery,\n  track\n}) {\n  // TODO: Ensure id corresponds to a valid resource, otherwise 404\n  // e.g. /documents/export and /documents/view should fail\n  const isDocumentFetched = !!document.textractResponse && !!document.comprehendMedicalResponse && !!document.comprehendResponse;\n  const {\n    status\n  } = useFetchDocument(dispatch, id, isDocumentFetched);\n  const pageCount = getDocumentPageCount(document);\n  const {\n    documentName,\n    documentURL,\n    searchablePdfURL\n  } = document; // Reset currentPageNumber on mount\n\n  useEffect(() => {\n    dispatch(setCurrentPageNumber(1));\n  }, [dispatch]);\n  useEffect(() => {\n    return () => {\n      dispatch(clearRedactions(id));\n    };\n  }, [dispatch, id]); // Set search results data\n\n  const wordsMatchingSearch = useMemo(() => {\n    return getPageWordsBySearch(document, currentPageNumber, searchQuery);\n  }, [document, currentPageNumber, searchQuery]);\n  const docData = useMemo(() => {\n    const pairs = getDocumentKeyValuePairs(document);\n    const tables = getDocumentTables(document);\n    const lines = getDocumentLines(document);\n    const entities = getDocumentEntityPairs(document, COMPREHEND_SERVICE);\n    const medicalEntities = getDocumentEntityPairs(document, COMPREHEND_MEDICAL_SERVICE);\n    return {\n      pairs,\n      tables,\n      lines,\n      entities,\n      medicalEntities\n    }; // eslint-disable-next-line\n  }, [document, document.textractResponse, document.medicalComprehendResponse, document.comprehendResponse]); // Set the paged content for each tab\n\n  const pageData = useMemo(() => {\n    const lines = getPageLines(document, currentPageNumber);\n    const pairs = docData.pairs.filter(d => d.pageNumber === currentPageNumber);\n    const tables = docData.tables.filter(d => d.pageNumber === currentPageNumber);\n    const entities = docData.entities.filter(d => d.pageNumber === currentPageNumber);\n    const medicalEntities = docData.medicalEntities.filter(d => d.pageNumber === currentPageNumber);\n    return {\n      lines,\n      pairs,\n      tables,\n      entities,\n      medicalEntities\n    }; // eslint-disable-next-line\n  }, [document, document.textractResponse, document.comprehendMedicalResponse, currentPageNumber, docData.pairs, docData.entities, docData.medicalEntities, docData.tables]);\n  const {\n    0: tab,\n    1: selectTab\n  } = useState('search');\n  const {\n    0: trackTab,\n    1: selectTrack\n  } = useState('search');\n  const downloadKV = useCallback(async () => {\n    const {\n      resultDirectory\n    } = document;\n    const url = await Storage.get(`${resultDirectory}/textract/page-${currentPageNumber}-forms.csv`, {\n      expires: 300\n    });\n    window.open(url);\n  }, [currentPageNumber, document]);\n  const downloadEntities = useCallback(async () => {\n    const {\n      resultDirectory\n    } = document;\n    const url = await Storage.get(`${resultDirectory}/comprehend/comprehendEntities.json`, {\n      expires: 300\n    });\n    window.open(url);\n  }, [document]);\n  const downloadMedicalEntities = useCallback(async () => {\n    const {\n      resultDirectory\n    } = document;\n    const url = await Storage.get(`${resultDirectory}/comprehend/comprehendMedicalEntities.json`, {\n      expires: 300\n    });\n    window.open(url);\n  }, [document]);\n  const downloadMedicalICD10Ontologies = useCallback(async () => {\n    const {\n      resultDirectory\n    } = document;\n    const url = await Storage.get(`${resultDirectory}/comprehend/comprehendMedicalICD10.json`, {\n      expires: 300\n    });\n    window.open(url);\n  }, [document]);\n  const redactMatches = useCallback(async () => {\n    dispatch(addRedactions(id, currentPageNumber, wordsMatchingSearch));\n    dispatch(setDocumentSearchQuery(''));\n  }, [currentPageNumber, dispatch, id, wordsMatchingSearch]);\n  const redact = useCallback(async (bbox, pageNumber = currentPageNumber) => {\n    dispatch(addRedactions(id, pageNumber, [bbox]));\n  }, [currentPageNumber, dispatch, id]);\n  const highlightEntities = useCallback(async (bbox, pageNumber = currentPageNumber) => {\n    dispatch(addHighlights(id, pageNumber, bbox));\n  }, [currentPageNumber, dispatch, id]);\n  const clearReds = useCallback(() => {\n    dispatch(clearRedactions(id));\n  }, [dispatch, id]);\n  const redactAllValues = useCallback(async (bbox, pageNumber = currentPageNumber) => {\n    dispatch(addRedactions(id, currentPageNumber, pageData.pairs.map(p => p.valueBoundingBox)));\n  }, [currentPageNumber, dispatch, id, pageData.pairs]);\n  const redactEntityMatches = useCallback(async (pageNumber, bboxlist) => {\n    dispatch(addRedactions(id, pageNumber, bboxlist.map(p => p)));\n  }, [currentPageNumber, dispatch, id]);\n  const contentRef = useRef();\n  const downloadRedacted = useCallback(async () => {\n    const theThing = contentRef.current.querySelector('canvas,img');\n    const cnv = window.document.createElement('canvas'); // TODO the resolution is just based on the viewport for pdfs. It shouldn't be.\n\n    cnv.width = theThing.naturalWidth || theThing.width;\n    cnv.height = theThing.naturalHeight || theThing.height;\n    const ctx = cnv.getContext('2d');\n    ctx.drawImage(theThing, 0, 0);\n    ctx.fillStyle = '#000';\n\n    const x = val => val * cnv.width;\n\n    const y = val => val * cnv.height;\n\n    const margin = 2;\n    Object.values(document.redactions[currentPageNumber]).forEach(red => {\n      ctx.fillRect(x(red.Left) - margin, y(red.Top) - margin, x(red.Width) + 2 * margin, y(red.Height) + 2 * margin);\n    });\n    cnv.toBlob(blob => {\n      const a = window.document.createElement('a');\n      a.href = URL.createObjectURL(blob);\n      a.target = '_blank';\n      a.style.display = 'none';\n      a.download = document.objectName.split('/').pop().replace(/\\.[^.]+$/, '-REDACTED.png');\n      window.document.body.appendChild(a);\n      a.click();\n    }, 'image/png');\n  }, [currentPageNumber, document.objectName, document.redactions]);\n  const pagePairsAsMarks = useMemo(() => {\n    return pageData.pairs.reduce((acc, {\n      id,\n      keyBoundingBox,\n      valueBoundingBox\n    }) => {\n      return [...acc, _objectSpread(_objectSpread({}, keyBoundingBox), {}, {\n        id,\n        type: 'key'\n      }), _objectSpread(_objectSpread({}, valueBoundingBox), {}, {\n        id,\n        type: 'value'\n      })];\n    }, []);\n  }, [pageData.pairs]);\n  const pageLinesAsMarks = useMemo(() => {\n    return pageData.lines.map(({\n      id,\n      boundingBox\n    }) => {\n      return _objectSpread({\n        id\n      }, boundingBox);\n    });\n  }, [pageData.lines]);\n  const {\n    0: highlightedKv,\n    1: setHighlightedKv\n  } = useState(null);\n  useEffect(() => {\n    if (highlightedKv) {\n      setTimeout(() => {\n        setHighlightedKv(null);\n      }, 10);\n    }\n  }, [highlightedKv]);\n  const switchPage = useCallback(pageNumber => {\n    dispatch(setCurrentPageNumber(pageNumber));\n  }, [dispatch]);\n  const setHighlightedLine = useCallback(() => {}, []);\n  return __jsx(\"div\", {\n    className: css.document\n  }, status === 'pending' && __jsx(Loading, null), status === 'success' && __jsx(React.Fragment, null, __jsx(\"div\", {\n    className: css.tabWrapper\n  }, __jsx(Tabs, {\n    isTrackTab: false,\n    selected: tab,\n    track: track,\n    onSelectTab: selectTab,\n    items: [{\n      id: 'search',\n      title: 'Preview'\n    }, {\n      id: 'text',\n      title: 'Raw Text'\n    }, {\n      id: 'kv',\n      title: `Key-Value Pairs`\n    }, {\n      id: 'tables',\n      title: `Tables`\n    }, {\n      id: 'entities',\n      title: `Entities`\n    }, {\n      id: 'medical_entities',\n      title: `Medical Entities`\n    }]\n  }), track === 'redaction' && document.redactions && Object.keys(document.redactions).length ? __jsx(\"div\", {\n    className: css.downloadButtons\n  }, __jsx(Button, {\n    inverted: true,\n    onClick: clearReds\n  }, \"Clear Redaction\"), __jsx(Button, {\n    className: css.downloadRedacted,\n    onClick: downloadRedacted\n  }, \"\\u2B07 Redacted Doc\")) : null, __jsx(\"div\", null, __jsx(Tabs, {\n    isTrackTab: true,\n    selected: trackTab,\n    track: track,\n    onSelectTab: selectTrack,\n    items: [{\n      id: 'searchTrack',\n      title: 'Discovery'\n    }, {\n      id: 'complianceTrack',\n      title: 'Compliance'\n    }, {\n      id: 'workflowTrack',\n      title: 'Workflow Automation'\n    }]\n  }))), __jsx(\"div\", {\n    className: cs(css.searchBarWrapper, tab === 'search' && css.visible)\n  }, __jsx(DocumentSearchBar, {\n    className: css.searchBar,\n    placeholder: \"Search current document\\u2026\"\n  }), track === 'redaction' ? __jsx(Button, {\n    onClick: redactMatches\n  }, \"Redact matches\") : null), __jsx(\"div\", {\n    className: css.content,\n    ref: contentRef\n  }, __jsx(DocumentViewer, {\n    className: cs(css.tabSourceViewer, tab === 'kv' && css.withKv, tab === 'entities' && css.withEv, tab === 'medical_entities' && css.withEv, tab === 'text' && css.withText),\n    document: document,\n    pageCount: pageCount,\n    redactions: (document.redactions || {})[currentPageNumber],\n    marks: tab === 'search' ? wordsMatchingSearch : tab === 'text' ? pageLinesAsMarks : tab === 'kv' ? pagePairsAsMarks : tab === 'entities' ? document.highlights || [] : tab === 'medical_entities' ? document.highlights || [] : [],\n    tables: tab === 'tables' && pageData.tables,\n    highlightedMark: highlightedKv\n  }), __jsx(\"div\", {\n    className: cs(css.sidebar, (tab === 'kv' || tab === 'text' || tab === 'entities' || tab === 'medical_entities' || tab === 'search' || tab === 'text' || tab === 'tables') && css.visible)\n  }, __jsx(KeyValueList, {\n    kvPairs: docData.pairs,\n    pageCount: pageCount,\n    currentPageNumber: currentPageNumber,\n    showRedaction: track === 'redaction',\n    onHighlight: setHighlightedKv,\n    onSwitchPage: switchPage,\n    onRedact: redact,\n    onRedactAll: redactAllValues,\n    onDownload: downloadKV,\n    visible: tab === 'kv'\n  }), __jsx(DocumentPreview, {\n    document: document,\n    pageCount: pageCount,\n    visible: tab === 'search',\n    track: track\n  }), __jsx(RawTextLines, {\n    lines: docData.lines,\n    pageCount: pageCount,\n    currentPageNumber: currentPageNumber,\n    onHighlight: setHighlightedLine,\n    onSwitchPage: switchPage,\n    visible: tab === 'text'\n  }), __jsx(EntitiesCheckbox, {\n    entities: docData.entities,\n    pageCount: pageCount,\n    currentPageNumber: currentPageNumber,\n    showRedaction: track === 'redaction',\n    onHighlight: highlightEntities,\n    onSwitchPage: switchPage,\n    onRedact: redactEntityMatches,\n    onRedactAll: redactAllValues,\n    onDownload: downloadKV,\n    visible: tab === 'entities',\n    comprehendService: COMPREHEND_SERVICE,\n    onDownloadPrimary: downloadEntities,\n    onDownloadSecondary: null,\n    document: document\n  }), __jsx(EntitiesCheckbox, {\n    entities: docData.medicalEntities,\n    pageCount: pageCount,\n    currentPageNumber: currentPageNumber,\n    showRedaction: track === 'redaction',\n    onHighlight: highlightEntities,\n    onSwitchPage: switchPage,\n    onRedact: redactEntityMatches,\n    onRedactAll: redactAllValues,\n    onDownloadPrimary: downloadMedicalEntities,\n    onDownloadSecondary: downloadMedicalICD10Ontologies,\n    visible: tab === 'medical_entities',\n    comprehendService: COMPREHEND_MEDICAL_SERVICE,\n    document: document\n  }), __jsx(TableResults, {\n    tables: docData.tables,\n    pageCount: pageCount,\n    currentPageNumber: currentPageNumber,\n    onSwitchPage: switchPage,\n    visible: tab === 'tables',\n    document: document\n  })))));\n}\n\nexport default connect(function mapStateToProps(state) {\n  const {\n    id\n  } = queryString.parse(location.search);\n  return {\n    id,\n    currentPageNumber: getCurrentPageNumber(state, id),\n    document: getDocumentById(state, id),\n    searchQuery: getDocumentSearchQuery(state),\n    track: getSelectedTrackId(state)\n  };\n})(Document);\n/**\n * Conditionally fetch documents from the client side.\n *\n * @param {Function} dispatch Redux dispatch function\n * @param {Array} documents An array of documents\n * @param {Boolean} isDocumentFetched True if the document has already been fetched\n */\n\nfunction useFetchDocument(dispatch, id, isDocumentFetched) {\n  const isMounted = useRef(true);\n  const {\n    0: status,\n    1: setStatus\n  } = useState('');\n  useEffect(() => {\n    if (!isDocumentFetched) {\n      isMounted.current && setStatus('pending');\n      dispatch(fetchDocument(id)).then(meta => {\n        isMounted.current && setStatus('success');\n      }).catch(() => {\n        isMounted.current && setStatus('error');\n      });\n    } else {\n      isMounted.current && setStatus('success');\n    }\n  }, [dispatch, id, isDocumentFetched]); // Ensure we don't try to set state after component unmount\n\n  useEffect(() => () => isMounted.current = false, []);\n  return {\n    status\n  };\n}","map":null,"metadata":{},"sourceType":"module"}