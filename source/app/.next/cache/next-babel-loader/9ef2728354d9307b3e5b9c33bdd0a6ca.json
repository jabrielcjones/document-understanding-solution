{"ast":null,"code":"import _defineProperty from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/jabrielcjones/dev/belle_fleur/document-understanding-solution/source/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport { ascend, either, flatten, indexBy, is, isEmpty, isNil, lensPath, multiply, path, pipe, prop, range, reject, sortBy, sortWith, view, memoizeWith } from 'ramda';\nimport { COMPREHEND_MEDICAL_SERVICE, COMPREHEND_SERVICE } from './dus-constants'; // Location of Blocks within a document object\n\nvar lensDocumentBlocks = lensPath(['textractResponse', 'Blocks']); // Location of page count within single/multi page document\n\nvar lensPageCount = lensPath(['textractResponse', 'DocumentMetadata', 'Pages']);\nvar lensMultiPageCount = lensPath(['textractResponse', 0, 'DocumentMetadata', 'Pages']);\n/**\n * Get a PAGE block by page number\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber A page number\n * @return {Object}\n */\n\nfunction getPage(document, pageNumber) {\n  var blocks = getDocumentBlocks(document);\n  var pageBlocks = blocks.filter(function (_ref) {\n    var BlockType = _ref.BlockType,\n        Page = _ref.Page;\n    return (// Single page docs only have one PAGE, and it doesn't include a Page prop\n      BlockType === 'PAGE' && (Page === pageNumber || pageNumber === 1 && !Page)\n    );\n  });\n  return isEmpty(pageBlocks) ? {} : pageBlocks[0];\n}\n/**\n * Get all Blocks for a given document.\n * @param {Object} document A Textract document object\n * @return {Array}\n */\n\n\nfunction getDocumentBlocks(document) {\n  if (either(isNil, isEmpty)(document) || !document.textractResponse) return [];\n  var isChunkedResponse = is(Array, document.textractResponse);\n  var combinedChunks = isChunkedResponse && document.textractResponse.reduce(function (accumulator, _ref2) {\n    var Blocks = _ref2.Blocks;\n    return accumulator.concat(Blocks);\n  }, []);\n  return isChunkedResponse ? combinedChunks : view(lensDocumentBlocks, document) || [];\n}\n/**\n * Get all Blocks for a given document, in an object indexed by ID\n * @param {Object} document A Textract document object\n * @return {Object}\n */\n\n\nfunction getIndexedDocumentBlocks(document) {\n  var blocks = getDocumentBlocks(document);\n  var indexedBlocks = indexBy(prop('Id'), blocks);\n  return indexedBlocks;\n}\n/**\n * Memoized version of the above, since indexing blocks by ID is a\n * common and very expensive task on very large documents\n */\n\n\nvar memoizedGetIndexedBlocks = memoizeWith(function (doc) {\n  return [doc.id, doc.textractFetchedAt].join();\n}, getIndexedDocumentBlocks);\n/**\n * Get a list of Blocks matching the IDs provided.\n * @param {Object} document A Textract document object\n * @param {Array} ids An array of Block IDs to get\n * @return {Array}\n */\n\nfunction getDocumentBlocksByIds(document, ids) {\n  var indexedBlocks = memoizedGetIndexedBlocks(document);\n  return ids.reduce(function (accumulator, current) {\n    return indexedBlocks[current] ? [].concat(_toConsumableArray(accumulator), [indexedBlocks[current]]) : accumulator;\n  }, []);\n}\n/**\n * Get text/boolean content of VALUE or CELL Blocks.\n * @param {Object} document A Textract document object\n * @param {Array} ids An array of Block IDs\n * @return {Boolean|String}\n */\n\n\nfunction getCellOrValueContents(document, ids) {\n  if (!ids) return '';\n  var contentBlocks = getDocumentBlocksByIds(document, ids);\n  var isCheckbox = false;\n  var value = contentBlocks.map(function (_ref3) {\n    var Text = _ref3.Text,\n        BlockType = _ref3.BlockType,\n        SelectionStatus = _ref3.SelectionStatus;\n    if (BlockType === 'SELECTION_ELEMENT') isCheckbox = true;\n    return BlockType === 'WORD' ? Text : SelectionStatus === 'SELECTED';\n  }); // If the value is a checkbox, we want to retain it as a boolean value\n  // instead of joining it, which converts it to a string\n\n  return isCheckbox ? value[0] ? 'Yes' : 'No' : value.join(' ');\n}\n/**\n * Get a page's child Blocks of a given type.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber A page number\n * @param {String} type A BlockType\n * @return {Array}\n */\n\n\nfunction getPageChildrenByType(document, pageNumber, type) {\n  var Relationships = prop('Relationships', getPage(document, pageNumber)) || [];\n  var childBlockIds = path([0, 'Ids'], Relationships) || [];\n  var children = getDocumentBlocksByIds(document, childBlockIds);\n  var filteredChildren = type ? filterBlocksByType(children, type) : children;\n  return filteredChildren;\n}\n/**\n * Get test from a list of LINE Blocks\n * @param {Array} blocks An array of LINE Blocks\n * @return {Array}\n */\n\n\nfunction transformLineBlocksToText(blocks) {\n  return blocks.map(function (_ref4) {\n    var Text = _ref4.Text;\n    return Text;\n  });\n}\n/**\n * Filter a list of Blocks with a given BlockType.\n * @param {Array} blocks An array of Blocks\n * @param {String} type A BlockType\n * @return {Array}\n */\n\n\nfunction filterBlocksByType(blocks, type) {\n  return blocks.filter(function (_ref5) {\n    var BlockType = _ref5.BlockType;\n    return BlockType === type;\n  });\n}\n/**\n * Get the total number of pages in a document.\n * @param {Object} document A Textract document object\n * @return {Number}\n */\n\n\nexport function getDocumentPageCount(document) {\n  var isChunkedResponse = is(Array, document.textractResponse);\n  return view(isChunkedResponse ? lensMultiPageCount : lensPageCount, document);\n}\nexport function getDocumentLines(document) {\n  var totalPages = getDocumentPageCount(document);\n  var linesByPage = range(1, totalPages + 1).map(function (pageNumber) {\n    var lines = getPageLines(document, pageNumber);\n    return lines;\n  });\n  return flatten(linesByPage);\n}\n/**\n * Get lines of text found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getPageLines(document, pageNumber) {\n  var lines = getPageChildrenByType(document, pageNumber, 'LINE');\n  return lines.map(function (_ref6) {\n    var Text = _ref6.Text,\n        Geometry = _ref6.Geometry,\n        Page = _ref6.Page;\n    return {\n      text: Text,\n      pageNumber: Page,\n      boundingBox: Geometry.BoundingBox\n    };\n  });\n}\nexport function getDocumentBlocksByType(document, type) {\n  var blocks = getDocumentBlocks(document);\n  return filterBlocksByType(blocks, type);\n}\nexport function countDocumentKeyValuePairs(document) {\n  var keyValueSetBlocks = getDocumentBlocksByType(document, 'KEY_VALUE_SET'); // Filter those down to get the blocks of EntityType KEY\n  // NOTE: EntityTypes is an array, even though it only ever contains one value\n\n  var keyBlocks = keyValueSetBlocks.filter(function (_ref7) {\n    var EntityTypes = _ref7.EntityTypes;\n    return EntityTypes.indexOf('KEY') >= 0;\n  });\n  return keyBlocks.length;\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getDocumentKeyValuePairs(document) {\n  var totalPages = getDocumentPageCount(document);\n  var blocksByPage = range(1, totalPages + 1).map(function (pageNumber) {\n    var blocks = getPageKeyValuePairs(document, pageNumber);\n    return blocks.map(function (b) {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber: pageNumber\n      });\n    });\n  });\n  return flatten(blocksByPage);\n}\n/**\n * Get entities found in a page.\n * @param {Object} document A Comprehend document object\n * @param {String} comprehendService The comprehend Service being used : Comprehend/ComprehendMedical\n * @return {Array}\n */\n\nexport function getDocumentEntityPairs(document, comprehendService) {\n  var totalPages = getDocumentPageCount(document);\n  var MERGE_KEY = null;\n\n  if (comprehendService == COMPREHEND_MEDICAL_SERVICE) {\n    MERGE_KEY = 'Category';\n  } else {\n    MERGE_KEY = 'Type';\n  }\n\n  var blocksByPage = range(1, totalPages + 1).map(function (pageNumber) {\n    var blocks = getPageEntityPairs(document, pageNumber, comprehendService);\n    var entity_array = consolidateDictionaryList(blocks[\"Entities\"], MERGE_KEY, \"Text\");\n    return entity_array.map(function (b) {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber: pageNumber\n      });\n    });\n  });\n  return isEmpty(blocksByPage) ? [] : [].concat.apply([], blocksByPage);\n}\nexport function consolidateDictionaryList(dictionaryList, mergeKey, mergeValue) {\n  var output = [];\n  var entity_object = {};\n  var processing_dict = {};\n  dictionaryList.forEach(function (item) {\n    if (!(item[mergeKey] in processing_dict)) {\n      processing_dict[item[mergeKey]] = new Set();\n    }\n\n    processing_dict[item[mergeKey]].add(item[mergeValue]);\n  });\n  var entityDictKeys = Object.keys(processing_dict);\n\n  for (var _i = 0, _entityDictKeys = entityDictKeys; _i < _entityDictKeys.length; _i++) {\n    var key = _entityDictKeys[_i];\n    entity_object[\"entity\"] = key;\n    entity_object[\"value\"] = _toConsumableArray(processing_dict[key]);\n    output.push(entity_object);\n    entity_object = {};\n  }\n\n  return output;\n}\nexport function resetFormsonPage() {\n  var formsCollection = document.forms;\n\n  for (var i = 0; i < formsCollection.length; i++) {\n    formsCollection[i].reset();\n  }\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Comprehend/Comprehend Medical document object\n * @param {Number} pageNumber The page number to get results for\n * @param {String} comprehendService The comprehend service used : Comprehend/ComprehendMedical\n * @return {Array}\n */\n\nexport function getPageEntityPairs(document, pageNumber, comprehendService) {\n  // Get all blocks of Entities for a PAGE\n  var blocks = [];\n\n  if (comprehendService == COMPREHEND_MEDICAL_SERVICE) {\n    blocks = document.comprehendMedicalRespone[\"results\"];\n  } else {\n    blocks = document.comprehendRespone[\"results\"];\n  }\n\n  var pageBlocks = blocks.filter(function (_ref8) {\n    var Entities = _ref8.Entities,\n        Page = _ref8.Page;\n    return (// Single page docs only have one PAGE, and it doesn't include a Page prop\n      Page === pageNumber\n    );\n  });\n  return isEmpty(pageBlocks) ? {} : pageBlocks[0];\n}\n/**\n * Get forms found in a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @return {Array}\n */\n\nexport function getPageKeyValuePairs(document, pageNumber) {\n  // Get all blocks of BlockType KEY_VALUE_SET for a PAGE\n  var keyValueSetBlocks = getPageChildrenByType(document, pageNumber, 'KEY_VALUE_SET'); // Filter those down to get the blocks of EntityType KEY\n  // NOTE: EntityTypes is an array, even though it only ever contains one value\n\n  var keyBlocks = keyValueSetBlocks.filter(function (_ref9) {\n    var EntityTypes = _ref9.EntityTypes;\n    return EntityTypes.indexOf('KEY') >= 0;\n  }); // Iterate over each KEY block\n\n  var pairs = keyBlocks.map(function (_ref10) {\n    var Id = _ref10.Id,\n        Relationships = _ref10.Relationships,\n        Geometry = _ref10.Geometry;\n    // Get related VALUE blocks and WORD blocks for this KEY block\n    var valueBlockIds = path([0, 'Ids'], Relationships) || [];\n    var keyWordIds = path([1, 'Ids'], Relationships) || [];\n    var keyWordBlocks = getDocumentBlocksByIds(document, keyWordIds);\n    var valueBlocks = getDocumentBlocksByIds(document, valueBlockIds); // Get WORD blocks for each VALUE block\n\n    var valueWordIds = valueBlocks.reduce(function (accumulator, _ref11) {\n      var Relationships = _ref11.Relationships;\n      var childIds = Relationships ? Relationships[0].Ids : [];\n      return [].concat(_toConsumableArray(accumulator), _toConsumableArray(childIds));\n    }, []); // Finally, return a simple object containing joined KEY and VALUE words\n\n    var key = keyWordBlocks.map(function (_ref12) {\n      var Text = _ref12.Text;\n      return Text;\n    }).join(' ');\n    var value = getCellOrValueContents(document, valueWordIds);\n    return {\n      id: Id,\n      key: key,\n      value: value,\n      keyBoundingBox: Geometry.BoundingBox,\n      valueBoundingBox: valueBlocks[0].Geometry.BoundingBox\n    };\n  });\n  return sortBy(function (x) {\n    return x.keyBoundingBox.Top + 0.05 * x.keyBoundingBox.Left;\n  })(pairs.filter(function (p) {\n    return p.key || p.value;\n  }));\n}\nexport function getDocumentTables(document) {\n  var totalPages = getDocumentPageCount(document);\n  var blocksByPage = range(1, totalPages + 1).map(function (pageNumber) {\n    var blocks = getPageTables(document, pageNumber);\n    return blocks.map(function (b) {\n      return _objectSpread(_objectSpread({}, b), {}, {\n        pageNumber: pageNumber\n      });\n    });\n  });\n  return isEmpty(blocksByPage) ? [] : [].concat.apply([], blocksByPage);\n}\n/**\n * Get tables/rows/cells found in a page.\n * @param {Number} pageNumber The page number to get results for\n * @param {Object} document A Textract document object\n * @return {Array}\n */\n\nexport function getPageTables(document, pageNumber) {\n  // Get all blocks of BlockType TABLE for a PAGE\n  var tableBlocks = getPageChildrenByType(document, pageNumber, 'TABLE'); // Iterate each TABLE in order to build a new data structure\n\n  var tables = tableBlocks.map(function (table) {\n    var Relationships = table.Relationships; // Get all blocks of BlockType CELL within this TABLE\n\n    var cellBlockIds = path([0, 'Ids'], Relationships) || [];\n    var cellBlocks = getDocumentBlocksByIds(document, cellBlockIds); // Iterate each CELL in order to build an array for each row containing an object for each cell\n\n    var rowData = cellBlocks.reduce(function (accumulator, current) {\n      var RowIndex = current.RowIndex,\n          ColumnIndex = current.ColumnIndex,\n          RowSpan = current.RowSpan,\n          ColumnSpan = current.ColumnSpan,\n          Relationships = current.Relationships,\n          Geometry = current.Geometry;\n      var contentBlockIds = path([0, 'Ids'], Relationships) || [];\n      var row = accumulator[RowIndex - 1] || [];\n      row[ColumnIndex - 1] = {\n        RowIndex: RowIndex,\n        ColumnIndex: ColumnIndex,\n        RowSpan: RowSpan,\n        ColumnSpan: ColumnSpan,\n        content: getCellOrValueContents(document, contentBlockIds),\n        Geometry: Geometry\n      };\n      accumulator[RowIndex - 1] = row;\n      return accumulator;\n    }, []);\n    return {\n      table: table,\n      rows: rowData\n    };\n  });\n  return tables;\n}\nexport function getMultiPageWordsBySearch(document, pageNumber, wordList) {\n  var output = [];\n  wordList.forEach(function (item) {\n    output.push.apply(output, _toConsumableArray(getPageWordsBySearch(document, pageNumber, item)));\n  });\n  return output;\n}\n/**\n * Get WORD blocks that match a search query on a page.\n * @param {Object} document A Textract document object\n * @param {Number} pageNumber The page number to get results for\n * @param {String} searchQuery The string to find in the document\n * @return {Array}\n */\n\nexport function getPageWordsBySearch(document, pageNumber, searchQuery) {\n  if (!searchQuery) return [];\n  var searchQueryWords = reject(isEmpty, searchQuery.split(' '));\n\n  function escapeRegex(str) {\n    return str.replace(/[-[\\]{}()*+?.,\\\\^$|]/g, '\\\\$&');\n  }\n\n  var searchQueryRegex = RegExp(escapeRegex(searchQuery), 'i'); // Get all the LINE Blocks for a PAGE that match the searchQuery\n\n  var lines = getPageChildrenByType(document, pageNumber, 'LINE');\n  var matchingLines = lines.filter(function (_ref13) {\n    var Text = _ref13.Text;\n    return searchQueryRegex.test(Text);\n  }); // Get all the WORD Blocks for each LINE that match the searchQuery\n\n  var matchingWords = matchingLines.reduce(function (accumulator, _ref14) {\n    var Relationships = _ref14.Relationships;\n    var wordIds = path([0, 'Ids'], Relationships) || []; // Sort all the WORD Blocks in order from left to right\n\n    var wordBlocks = sortWith([ascend(path(['Geometry', 'BoundingBox', 'Left']))])(getDocumentBlocksByIds(document, wordIds));\n    var wordText = wordBlocks.map(function (word) {\n      return word.Text;\n    }).join(' ');\n    var matchRegexp = RegExp(escapeRegex(searchQueryWords.join(' ')), 'ig');\n    var res;\n\n    function getWordIndexByStringIndex(idx) {\n      var searchIndex = 0;\n      var wordIndex;\n\n      for (wordIndex = 0; wordIndex < wordBlocks.length; wordIndex++) {\n        var word = wordBlocks[wordIndex];\n        if (idx < searchIndex + word.Text.length + 1) return wordIndex;\n        searchIndex += word.Text.length + 1;\n      }\n\n      return wordIndex;\n    }\n\n    var matchingWordBlocks = [];\n\n    while ((res = matchRegexp.exec(wordText)) !== null) {\n      var startIndex = res.index;\n      var endIndex = startIndex + res[0].length;\n      var startWord = getWordIndexByStringIndex(startIndex);\n      var endWord = getWordIndexByStringIndex(endIndex);\n\n      for (var i = startWord; i <= endWord; i++) {\n        if (!matchingWordBlocks.includes(wordBlocks[i])) matchingWordBlocks.push(wordBlocks[i]);\n      }\n    } // TODO most of the below logic can probably be removed / consolidated into the above\n    // Pick specific props from each WORD Block\n\n\n    var matchingWordBounds = matchingWordBlocks.map(function (_ref15) {\n      var Text = _ref15.Text,\n          _ref15$Geometry$Bound = _ref15.Geometry.BoundingBox,\n          Top = _ref15$Geometry$Bound.Top,\n          Left = _ref15$Geometry$Bound.Left,\n          Width = _ref15$Geometry$Bound.Width,\n          Height = _ref15$Geometry$Bound.Height;\n      return {\n        Text: Text,\n        Top: Top,\n        Left: Left,\n        Width: Width,\n        Height: Height\n      };\n    }); // Sort all the words by their location from top/left to bottom/right\n\n    var matchingWordBoundsSorted = sortWith([function (_ref16, _ref17) {\n      var a = _ref16.Top;\n      var b = _ref17.Top;\n      var difference = pipe(Math.abs, multiply(100), Math.floor)(a - b);\n      return !difference ? 0 : a < b ? -1 : a > b ? 1 : 0;\n    }, ascend(path(['Left']))])(matchingWordBounds); // Combine words together such that they match the query (and merge their bounding box info)\n\n    var unmatched = null;\n    var matchingWordBoundsCombined = matchingWordBoundsSorted.reduce(function (accumulator, word) {\n      var wordMatches = searchQueryRegex.test(word.Text); // If a single word matches the query, add it to the list\n\n      if (wordMatches) {\n        unmatched = null;\n        return [].concat(_toConsumableArray(accumulator), [word]);\n      } // If there's an unmatched word from a previous iteration,\n      // see if combining the two will match the query\n\n\n      if (unmatched) {\n        var combinedText = \"\".concat(unmatched.Text, \" \").concat(word.Text);\n        var combinedWords = {\n          Text: combinedText,\n          Top: Math.max(unmatched.Top, word.Top),\n          Left: Math.min(unmatched.Left, word.Left),\n          Width: word.Left - unmatched.Left + word.Width,\n          Height: Math.max(unmatched.Height, word.Height)\n        };\n        var combinedWordsMatch = searchQueryRegex.test(combinedText); // If the combined words match the query, add it to the list\n\n        if (combinedWordsMatch) {\n          unmatched = null;\n          return [].concat(_toConsumableArray(accumulator), [combinedWords]);\n        } // Otherwise, update unmatched with the combined words object\n\n\n        unmatched = combinedWords;\n      } else {\n        // If there wasn't an unmatched word from a previous iteration, set unmatched\n        unmatched = word;\n      }\n\n      return accumulator;\n    }, []);\n    return accumulator.concat(matchingWordBoundsCombined);\n  }, []);\n  return matchingWords;\n}","map":null,"metadata":{},"sourceType":"module"}