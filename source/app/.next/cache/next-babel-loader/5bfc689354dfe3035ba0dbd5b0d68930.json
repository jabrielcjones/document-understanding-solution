{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**********************************************************************************************************************\n *  Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.                                           *\n *                                                                                                                    *\n *  Licensed under the Apache License, Version 2.0 (the License). You may not use this file except in compliance    *\n *  with the License. A copy of the License is located at                                                             *\n *                                                                                                                    *\n *      http://www.apache.org/licenses/LICENSE-2.0                                                                    *\n *                                                                                                                    *\n *  or in the 'license' file accompanying this file. This file is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES *\n *  OR CONDITIONS OF ANY KIND, express or implied. See the License for the specific language governing permissions    *\n *  and limitations under the License.                                                                                *\n *********************************************************************************************************************/\nimport { createAction } from \"redux-actions\";\nimport { either, isEmpty, isNil, lensPath, reject, view } from \"ramda\";\nimport { normalize } from \"normalizr\";\nimport { API, Storage, Auth } from \"aws-amplify\";\nimport uuid from \"uuid/v4\";\nimport { SUBMIT_DOCUMENTS, SUBMIT_DOCUMENT, FETCH_DOCUMENTS, FETCH_DOCUMENT, REDACT_DOCUMENT, HIGHLIGHT_DOCUMENT } from \"../../../constants/action-types\";\nimport { documentsSchema, documentSchema } from \"./data\";\nconst lensNextToken = lensPath([\"data\", \"nextToken\"]);\nconst lensDocumentsTotal = lensPath([\"data\", \"Total\"]);\nconst lensDocumentsData = lensPath([\"data\", \"documents\"]);\nconst lensDocumentData = lensPath([\"data\"]);\nexport const submitDocument = createAction(SUBMIT_DOCUMENT, async ({\n  sample,\n  key\n}) => {\n  const response = await API.post(\"TextractDemoTextractAPI\", \"document\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    body: {\n      sample: !!sample,\n      key\n    }\n  });\n  const data = view(lensDocumentData, response);\n  return data;\n});\nexport const submitDocuments = createAction(SUBMIT_DOCUMENTS, async ({\n  objects\n}) => {\n  const response = await API.post(\"TextractDemoTextractAPI\", \"document\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    body: {\n      objects\n    }\n  });\n  const data = view(lensDocumentData, response);\n  return data;\n});\n/**\n * Get documents from TextractDemoTextractAPIs\n */\n\nexport const fetchDocuments = createAction(FETCH_DOCUMENTS, async ({\n  nextToken: nexttoken\n} = {}) => {\n  const response = await API.get(\"TextractDemoTextractAPI\", \"documents\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    queryStringParameters: reject(either(isNil, isEmpty), {\n      nexttoken,\n      type: \"user\"\n    })\n  });\n  const documentsNextToken = view(lensNextToken, response) || null;\n  const documentsTotal = view(lensDocumentsTotal, response);\n  const documents = view(lensDocumentsData, response).map(document => _objectSpread(_objectSpread({}, document), {}, {\n    documentName: document.objectName.replace(/^.*\\//, \"\")\n  }));\n  const {\n    entities\n  } = normalize(documents, documentsSchema);\n  const meta = reject(isNil, {\n    documentsNextToken,\n    documentsTotal\n  });\n  return _objectSpread(_objectSpread({}, entities), {}, {\n    meta\n  });\n});\nexport const fetchSingleDocument = createAction(FETCH_DOCUMENT, async documentid => {\n  const response = await API.get(\"TextractDemoTextractAPI\", \"document\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    queryStringParameters: {\n      documentid\n    }\n  });\n  const document = view(lensDocumentData, response);\n  return normalize(document, documentSchema).entities;\n});\n/**\n * Get document from TextractDemoTextractAPI\n */\n\nexport const fetchDocument = createAction(FETCH_DOCUMENT, async documentid => {\n  const response = await API.get(\"TextractDemoTextractAPI\", \"document\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    queryStringParameters: {\n      documentid\n    }\n  });\n  const document = view(lensDocumentData, response);\n  const {\n    documentId,\n    objectName,\n    bucketName\n  } = document; // Remove the last slash and everything before it\n\n  const documentName = objectName.replace(/^.*\\//, \"\");\n  const fileNameWithoutExtension = documentName.split(\".\")[0]; // Amplify prepends public/ to the path, so we have to strip it\n\n  const documentPublicSubPath = objectName.replace(\"public/\", \"\");\n  const resultDirectory = `${documentId}/output`;\n  const textractResponsePath = `${resultDirectory}/textract/response.json`;\n  const comprehendMedicalResponsePath = `${resultDirectory}/comprehend/comprehendMedicalEntities.json`;\n  const comprehendResponsePath = `${resultDirectory}/comprehend/comprehendEntities.json`; // Get a pre-signed URL for the original document upload\n\n  const [documentData, searchablePdfData] = await Promise.all([Storage.get(documentPublicSubPath, {\n    bucket: bucketName,\n    download: true\n  }), Storage.get(`${resultDirectory}/${fileNameWithoutExtension}-searchable.pdf`, {\n    download: true\n  })]);\n  const documentBlob = new Blob([documentData.Body], {\n    type: documentData.contentType\n  });\n  const searchablePdfBlob = new Blob([searchablePdfData.Body], {\n    type: \"application/pdf\"\n  }); // Get the raw textract response data from a json file on S3\n\n  const s3Response = await Storage.get(textractResponsePath, {\n    download: true\n  });\n  const textractResponse = JSON.parse(s3Response.Body ? s3Response.Body.toString() : null); // Get the raw comprehend medical response data from a json file on S3\n\n  const s3ComprehendMedicalResponse = await Storage.get(comprehendMedicalResponsePath, {\n    download: true\n  });\n  const comprehendMedicalRespone = JSON.parse(s3ComprehendMedicalResponse.Body ? s3ComprehendMedicalResponse.Body.toString() : null); // Get the raw comprehend response data from a json file on S3\n\n  const s3ComprehendResponse = await Storage.get(comprehendResponsePath, {\n    download: true\n  });\n  const comprehendRespone = JSON.parse(s3ComprehendResponse.Body ? s3ComprehendResponse.Body.toString() : null);\n  return normalize(_objectSpread(_objectSpread({}, document), {}, {\n    documentURL: URL.createObjectURL(documentBlob),\n    searchablePdfURL: URL.createObjectURL(searchablePdfBlob),\n    documentName,\n    textractResponse,\n    textractFetchedAt: Date.now(),\n    comprehendMedicalRespone,\n    comprehendRespone,\n    resultDirectory\n  }), documentSchema).entities;\n});\nexport const deleteDocument = createAction(FETCH_DOCUMENT, async documentid => {\n  const response = await API.del(\"TextractDemoTextractAPI\", \"document\", {\n    headers: {\n      Authorization: `Bearer ${(await Auth.currentSession()).getIdToken().getJwtToken()}`\n    },\n    response: true,\n    queryStringParameters: {\n      documentid\n    }\n  });\n  return normalize({\n    documentId: documentid,\n    deleted: true\n  }, documentSchema).entities;\n});\nexport const addRedactions = createAction(REDACT_DOCUMENT, (documentId, pageNumber, redactions) => {\n  const keyedRedactions = redactions.reduce((acc, r) => {\n    acc[uuid()] = r;\n    return acc;\n  }, {});\n  return normalize({\n    documentId,\n    redactions: {\n      [pageNumber]: keyedRedactions\n    }\n  }, documentSchema).entities;\n});\nexport const addHighlights = createAction(HIGHLIGHT_DOCUMENT, (documentId, pageNumber, highlights) => {\n  const response = normalize({\n    documentId,\n    highlights: highlights\n  }, documentSchema).entities;\n  return response;\n});\nexport const clearRedactions = createAction(REDACT_DOCUMENT, documentId => {\n  return normalize({\n    documentId,\n    redactions: false\n  }, documentSchema).entities;\n});\nexport const clearHighlights = createAction(HIGHLIGHT_DOCUMENT, documentId => {\n  return normalize({\n    documentId,\n    highlights: []\n  }, documentSchema).entities;\n});","map":null,"metadata":{},"sourceType":"module"}